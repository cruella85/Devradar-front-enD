// -*- C++ -*-
//===----------------------------------------------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//

#ifndef _LIBCPP_STRING
#define _LIBCPP_STRING

/*
    string synopsis

namespace std
{

template <class stateT>
class fpos
{
private:
    stateT st;
public:
    fpos(streamoff = streamoff());

    operator streamoff() const;

    stateT state() const;
    void state(stateT);

    fpos& operator+=(streamoff);
    fpos  operator+ (streamoff) const;
    fpos& operator-=(streamoff);
    fpos  operator- (streamoff) const;
};

template <class stateT> streamoff operator-(const fpos<stateT>& x, const fpos<stateT>& y);

template <class stateT> bool operator==(const fpos<stateT>& x, const fpos<stateT>& y);
template <class stateT> bool operator!=(const fpos<stateT>& x, const fpos<stateT>& y);

template <class charT>
struct char_traits
{
    typedef charT     char_type;
    typedef ...       int_type;
    typedef streamoff off_type;
    typedef streampos pos_type;
    typedef mbstate_t state_type;

    static void assign(char_type& c1, const char_type& c2) noexcept;
    static constexpr bool eq(char_type c1, char_type c2) noexcept;
    static constexpr bool lt(char_type c1, char_type c2) noexcept;

    static int              compare(const char_type* s1, const char_type* s2, size_t n);
    static size_t           length(const char_type* s);
    static const char_type* find(const char_type* s, size_t n, const char_type& a);
    static char_type*       move(char_type* s1, const char_type* s2, size_t n);
    static char_type*       copy(char_type* s1, const char_type* s2, size_t n);
    static char_type*       assign(char_type* s, size_t n, char_type a);

    static constexpr int_type  not_eof(int_type c) noexcept;
    static constexpr char_type to_char_type(int_type c) noexcept;
    static constexpr int_type  to_int_type(char_type c) noexcept;
    static constexpr bool      eq_int_type(int_type c1, int_type c2) noexcept;
    static constexpr int_type  eof() noexcept;
};

template <> struct char_traits<char>;
template <> struct char_traits<wchar_t>;
template <> struct char_traits<char8_t>;  // C++20
template <> struct char_traits<char16_t>;
template <> struct char_traits<char32_t>;

template<class charT, class traits = char_traits<charT>, class Allocator = allocator<charT> >
class basic_string
{
public:
// types:
    typedef traits traits_type;
    typedef typename traits_type::char_type value_type;
    typedef Allocator allocator_type;
    typedef typename allocator_type::size_type size_type;
    typedef typename allocator_type::difference_type difference_type;
    typedef typename allocator_type::reference reference;
    typedef typename allocator_type::const_reference const_reference;
    typedef typename allocator_type::pointer pointer;
    typedef typename allocator_type::const_pointer const_pointer;
    typedef implementation-defined iterator;
    typedef implementation-defined const_iterator;
    typedef std::reverse_iterator<iterator> reverse_iterator;
    typedef std::reverse_iterator<const_iterator> const_reverse_iterator;

    static const size_type npos = -1;

    basic_string()
        noexcept(is_nothrow_default_constructible<allocator_type>::value);                      // constexpr since C++20
    explicit basic_string(const allocator_type& a);                                             // constexpr since C++20
    basic_string(const basic_string& str);                                                      // constexpr since C++20
    basic_string(basic_string&& str)
        noexcept(is_nothrow_move_constructible<allocator_type>::value);                         // constexpr since C++20
    basic_string(const basic_string& str, size_type pos,
                 const allocator_type& a = allocator_type());                                   // constexpr since C++20
    basic_string(const basic_string& str, size_type pos, size_type n,
                 const Allocator& a = Allocator());                                             // constexpr since C++20
    template<class T>
        basic_string(const T& t, size_type pos, size_type n, const Allocator& a = Allocator()); // C++17, constexpr since C++20
    template <class T>
        explicit basic_string(const T& t, const Allocator& a = Allocator());                    // C++17, constexpr since C++20
    basic_string(const value_type* s, const allocator_type& a = allocator_type());              // constexpr since C++20
    basic_string(const value_type* s, size_type n, const allocator_type& a = allocator_type()); // constexpr since C++20
    basic_string(nullptr_t) = delete; // C++2b
    basic_string(size_type n, value_type c, const allocator_type& a = allocator_type());        // constexpr since C++20
    template<class InputIterator>
        basic_string(InputIterator begin, InputIterator end,
                     const allocator_type& a = allocator_type());                               // constexpr since C++20
    basic_string(initializer_list<value_type>, const Allocator& = Allocator());                 // constexpr since C++20
    basic_string(const basic_string&, const Allocator&);                                        // constexpr since C++20
    basic_string(basic_string&&, const Allocator&);                                             // constexpr since C++20

    ~basic_string();                                                                            // constexpr since C++20

    operator basic_string_view<charT, traits>() const noexcept;                                 // constexpr since C++20

    basic_string& operator=(const basic_string& str);                                           // constexpr since C++20
    template <class T>
        basic_string& operator=(const T& t);                                                    // C++17, constexpr since C++20
    basic_string& operator=(basic_string&& str)
        noexcept(
             allocator_type::propagate_on_container_move_assignment::value ||
             allocator_type::is_always_equal::value );                                          // C++17, constexpr since C++20
    basic_string& operator=(const value_type* s);                                               // constexpr since C++20
    basic_string& operator=(nullptr_t) = delete; // C++2b
    basic_string& operator=(value_type c);                                                      // constexpr since C++20
    basic_string& operator=(initializer_list<value_type>);                                      // constexpr since C++20

    iterator       begin() noexcept;                                                            // constexpr since C++20
    const_iterator begin() const noexcept;                                                      // constexpr since C++20
    iterator       end() noexcept;                                                              // constexpr since C++20
    const_iterator end() const noexcept;                                                        // constexpr since C++20

    reverse_iterator       rbegin() noexcept;                                                   // constexpr since C++20
    const_reverse_iterator rbegin() const noexcept;                                             // constexpr since C++20
    reverse_iterator       rend() noexcept;                                                     // constexpr since C++20
    const_reverse_iterator rend() const noexcept;                                               // constexpr since C++20

    const_iterator         cbegin() const noexcept;                                             // constexpr since C++20
    const_iterator         cend() const noexcept;                                               // constexpr since C++20
    const_reverse_iterator crbegin() const noexcept;                                            // constexpr since C++20
    const_reverse_iterator crend() const noexcept;                                              // constexpr since C++20

    size_type size() const noexcept;                                                            // constexpr since C++20
    size_type length() const noexcept;                                                          // constexpr since C++20
    size_type max_size() const noexcept;                                                        // constexpr since C++20
    size_type capacity() const noexcept;                                                        // constexpr since C++20

    void resize(size_type n, value_type c);                                                     // constexpr since C++20
    void resize(size_type n);                                                                   // constexpr since C++20

    template<class Operation>
    constexpr void resize_and_overwrite(size_type n, Operation op); // since C++23

    void reserve(size_type res_arg);                                                            // constexpr since C++20
    void reserve(); // deprecated in C++20
    void shrink_to_fit();                                                                       // constexpr since C++20
    void clear() noexcept;                                                                      // constexpr since C++20
    bool empty() const noexcept;                                                                // constexpr since C++20

    const_reference operator[](size_type pos) const;                                            // constexpr since C++20
    reference       operator[](size_type pos);                                                  // constexpr since C++20

    const_reference at(size_type n) const;                                                      // constexpr since C++20
    reference       at(size_type n);                                                            // constexpr since C++20

    basic_string& operator+=(const basic_string& str);                                          // constexpr since C++20
    template <class T>
        basic_string& operator+=(const T& t);                                                   // C++17, constexpr since C++20
    basic_string& operator+=(const value_type* s);                                              // constexpr since C++20
    basic_string& operator+=(value_type c);                                                     // constexpr since C++20
    basic_string& operator+=(initializer_list<value_type>);                                     // constexpr since C++20

    basic_string& append(const basic_string& str);                                              // constexpr since C++20
    template <class T>
        basic_string& append(const T& t);                                                       // C++17, constexpr since C++20
    basic_string& append(const basic_string& str, size_type pos, size_type n=npos);             // C++14, constexpr since C++20
    template <class T>
        basic_string& append(const T& t, size_type pos, size_type n=npos);                      // C++17, constexpr since C++20
    basic_string& append(const value_type* s, size_type n);                                     // constexpr since C++20
    basic_string& append(const value_type* s);                                                  // constexpr since C++20
    basic_string& append(size_type n, value_type c);                                            // constexpr since C++20
    template<class InputIterator>
        basic_string& append(InputIterator first, InputIterator last);                          // constexpr since C++20
    basic_string& append(initializer_list<value_type>);                                         // constexpr since C++20

    void push_back(value_type c);                                                               // constexpr since C++20
    void pop_back();                                                                            // constexpr since C++20
    reference       front();                                                                    // constexpr since C++20
    const_reference front() const;                                                              // constexpr since C++20
    reference       back();                                                                     // constexpr since C++20
    const_reference back() const;                                                               // constexpr since C++20

    basic_string& assign(const basic_string& str);                                              // constexpr since C++20
    template <class T>
        basic_string& assign(const T& t);                                                       // C++17, constexpr since C++20
    basic_string& assign(basic_string&& str);                                                   // constexpr since C++20
    basic_string& assign(const basic_string& str, size_type pos, size_type n=npos);             // C++14, constexpr since C++20
    template <class T>
        basic_string& assign(const T& t, size_type pos, size_type n=npos);                      // C++17, constexpr since C++20
    basic_string& assign(const value_type* s, size_type n);                                     // constexpr since C++20
    basic_string& assign(const value_type* s);                                                  // constexpr since C++20
    basic_string& assign(size_type n, value_type c);                                            // constexpr since C++20
    template<class InputIterator>
        basic_string& assign(InputIterator first, InputIterator last);                          // constexpr since C++20
    basic_string& assign(initializer_list<value_type>);                                         // constexpr since C++20

    basic_string& insert(size_type pos1, const basic_string& str);                              // constexpr since C++20
    template <class T>
        basic_string& insert(size_type pos1, const T& t);                                       // constexpr since C++20
    basic_string& insert(size_type pos1, const basic_string& str,
                         size_type pos2, size_type n);                                          // constexpr since C++20
    template <class T>
        basic_string& insert(size_type pos1, const T& t, size_type pos2, size_type n);          // C++17, constexpr since C++20
    basic_string& insert(size_type pos, const value_type* s, size_type n=npos);                 // C++14, constexpr since C++20
    basic_string& insert(size_type pos, const value_type* s);                                   // constexpr since C++20
    basic_string& insert(size_type pos, size_type n, value_type c);                             // constexpr since C++20
    iterator      insert(const_iterator p, value_type c);                                       // constexpr since C++20
    iterator      insert(const_iterator p, size_type n, value_type c);                          // constexpr since C++20
    template<class InputIterator>
        iterator insert(const_iterator p, InputIterator first, InputIterator last);             // constexpr since C++20
    iterator      insert(const_iterator p, initializer_list<value_type>);                       // constexpr since C++20

    basic_string& erase(size_type pos = 0, size_type n = npos);                                 // constexpr since C++20
    iterator      erase(const_iterator position);                                               // constexpr since C++20
    iterator      erase(const_iterator first, const_iterator last);                             // constexpr since C++20

    basic_string& replace(size_type pos1, size_type n1, const basic_string& str);               // constexpr since C++20
    template <class T>
    basic_string& replace(size_type pos1, size_type n1, const T& t);                            // C++17, constexpr since C++20
    basic_string& replace(size_type pos1, size_type n1, const basic_string& str,
                          size_type pos2, size_type n2=npos);                                   // C++14, constexpr since C++20
    template <class T>
        basic_string& replace(size_type pos1, size_type n1, const T& t,
                              size_type pos2, size_type n);                                     // C++17, constexpr since C++20
    basic_string& replace(size_type pos, size_type n1, const value_type* s, size_type n2);      // constexpr since C++20
    basic_string& replace(size_type pos, size_type n1, const value_type* s);                    // constexpr since C++20
    basic_string& replace(size_type pos, size_type n1, size_type n2, value_type c);             // constexpr since C++20
    basic_string& replace(const_iterator i1, const_iterator i2, const basic_string& str);       // constexpr since C++20
    template <class T>
        basic_string& replace(const_iterator i1, const_iterator i2, const T& t);                // C++17, constexpr since C++20
    basic_string& replace(const_iterator i1, const_iterator i2, const value_type* s, size_type n); // constexpr since C++20
    basic_string& replace(const_iterator i1, const_iterator i2, const value_type* s);           // constexpr since C++20
    basic_string& replace(const_iterator i1, const_iterator i2, size_type n, value_type c);     // constexpr since C++20
    template<class InputIterator>
        basic_string& replace(const_iterator i1, const_iterator i2, InputIterator j1, InputIterator j2); // constexpr since C++20
    basic_string& replace(const_iterator i1, const_iterator i2, initializer_list<value_type>);  // constexpr since C++20

    size_type copy(value_type* s, size_type n, size_type pos = 0) const;                        // constexpr since C++20
    basic_string substr(size_type pos = 0, size_type n = npos) const;                           // constexpr since C++20

    void swap(basic_string& str)
        noexcept(allocator_traits<allocator_type>::propagate_on_container_swap::value ||
                 allocator_traits<allocator_type>::is_always_equal::value);                     // C++17, constexpr since C++20

    const value_type* c_str() const noexcept;                                                   // constexpr since C++20
    const value_type* data() const noexcept;                                                    // constexpr since C++20
          value_type* data()       noexcept;                                                    // C++17, constexpr since C++20

    allocator_type get_allocator() const noexcept;                                              // constexpr since C++20

    size_type find(const basic_string& str, size_type pos = 0) const noexcept;                  // constexpr since C++20
    template <class T>
        size_type find(const T& t, size_type pos = 0) const noexcept;                           // C++17, noexcept as an extension, constexpr since C++20
    size_type find(const value_type* s, size_type pos, size_type n) const noexcept;             // constexpr since C++20
    size_type find(const value_type* s, size_type pos = 0) const noexcept;                      // constexpr since C++20
    size_type find(value_type c, size_type pos = 0) const noexcept;                             // constexpr since C++20

    size_type rfind(const basic_string& str, size_type pos = npos) const noexcept;              // constexpr since C++20
    template <class T>
        size_type rfind(const T& t, size_type pos = npos) const noexcept;                       // C++17, noexcept as an extension, constexpr since C++20
    size_type rfind(const value_type* s, size_type pos, size_type n) const noexcept;            // constexpr since C++20
    size_type rfind(const value_type* s, size_type pos = npos) const noexcept;                  // constexpr since C++20
    size_type rfind(value_type c, size_type pos = npos) const noexcept;                         // constexpr since C++20

    size_type find_first_of(const basic_string& str, size_type pos = 0) const noexcept;         // constexpr since C++20
    template <class T>
        size_type find_first_of(const T& t, size_type pos = 0) const noexcept;                  // C++17, noexcept as an extension, constexpr since C++20
    size_type find_first_of(const value_type* s, size_type pos, size_type n) const noexcept;    // constexpr since C++20
    size_type find_first_of(const value_type* s, size_type pos = 0) const noexcept;             // constexpr since C++20
    size_type find_first_of(value_type c, size_type pos = 0) const noexcept;                    // constexpr since C++20

    size_type find_last_of(const basic_string& str, size_type pos = npos) const noexcept;       // constexpr since C++20
    template <class T>
        size_type find_last_of(const T& t, size_type pos = npos) const noexcept noexcept;       // C++17, noexcept as an extension, constexpr since C++20
    size_type find_last_of(const value_type* s, size_type pos, size_type n) const noexcept;     // constexpr since C++20
    size_type find_last_of(const value_type* s, size_type pos = npos) const noexcept;           // constexpr since C++20
    size_type find_last_of(value_type c, size_type pos = npos) const noexcept;                  // constexpr since C++20

    size_type find_first_not_of(const basic_string& str, size_type pos = 0) const noexcept;     // constexpr since C++20
    template <class T>
        size_type find_first_not_of(const T& t, size_type pos = 0) const noexcept;              // C++17, noexcept as an extension, constexpr since C++20
    size_type find_first_not_of(const value_type* s, size_type pos, size_type n) const noexcept; // constexpr since C++20
    size_type find_first_not_of(const value_type* s, size_type pos = 0) const noexcept;         // constexpr since C++20
    size_type find_first_not_of(value_type c, size_type pos = 0) const noexcept;                // constexpr since C++20

    size_type find_last_not_of(const basic_string& str, size_type pos = npos) const noexcept;   // constexpr since C++20
    template <class T>
        size_type find_last_not_of(const T& t, size_type pos = npos) const noexcept;            // C++17, noexcept as an extension, constexpr since C++20
    size_type find_last_not_of(const value_type* s, size_type pos, size_type n) const noexcept; // constexpr since C++20
    size_type find_last_not_of(const value_type* s, size_type pos = npos) const noexcept;       // constexpr since C++20
    size_type find_last_not_of(value_type c, size_type pos = npos) const noexcept;              // constexpr since C++20

    int compare(const basic_string& str) const noexcept;                                        // constexpr since C++20
    template <class T>
        int compare(const T& t) const noexcept;                                                 // C++17, noexcept as an extension, constexpr since C++20
    int compare(size_type pos1, size_type n1, const basic_string& str) const;                   // constexpr since C++20
    template <class T>
        int compare(size_type pos1, size_type n1, const T& t) const;                            // C++17, constexpr since C++20
    int compare(size_type pos1, size_type n1, const basic_string& str,
                size_type pos2, size_type n2=npos) const;                                       // C++14, constexpr since C++20
    template <class T>
        int compare(size_type pos1, size_type n1, const T& t,
                    size_type pos2, size_type n2=npos) const;                                   // C++17, constexpr since C++20
    int compare(const value_type* s) const noexcept;                                            // constexpr since C++20
    int compare(size_type pos1, size_type n1, const value_type* s) const;                       // constexpr since C++20
    int compare(size_type pos1, size_type n1, const value_type* s, size_type n2) const;         // constexpr since C++20

    constexpr bool starts_with(basic_string_view<charT, traits> sv) const noexcept;             // C++20
    constexpr bool starts_with(charT c) const noexcept;                                         // C++20
    constexpr bool starts_with(const charT* s) const;                                           // C++20
    constexpr bool ends_with(basic_string_view<charT, traits> sv) const noexcept;               // C++20
    constexpr bool ends_with(charT c) const noexcept;                                           // C++20
    constexpr bool ends_with(const charT* s) const;                                             // C++20

    constexpr bool contains(basic_string_view<charT, traits> sv) const noexcept;                // C++2b
    constexpr bool contains(charT c) const noexcept;                                            // C++2b
    constexpr bool contains(const charT* s) const;                                              // C++2b
};

template<class InputIterator,
         class Allocator = allocator<typename iterator_traits<InputIterator>::value_type>>
basic_string(InputIterator, InputIterator, Allocator = Allocator())
   -> basic_string<typename iterator_traits<InputIterator>::value_type,
                  char_traits<typename iterator_traits<InputIterator>::value_type>,
                  Allocator>;   // C++17

template<class charT, class traits, class Allocator>
basic_string<charT, traits, Allocator>
operator+(const basic_string<charT, traits, Allocator>& lhs,
          const basic_string<charT, traits, Allocator>& rhs);                                   // constexpr since C++20

template<class charT, class traits, class Allocator>
basic_string<charT, traits, Allocator>
operator+(const charT* lhs , const basic_string<charT,traits,Allocator>&rhs);                   // constexpr since C++20

template<class charT, class traits, class Allocator>
basic_string<charT, traits, Allocator>
operator+(charT lhs, const basic_string<charT,traits,Allocator>& rhs);                          // constexpr since C++20

template<class charT, class traits, class Allocator>
basic_string<charT, traits, Allocator>
operator+(const basic_string<charT, traits, Allocator>& lhs, const charT* rhs);                 // constexpr since C++20

template<class charT, class traits, class Allocator>
basic_string<charT, traits, Allocator>
operator+(const basic_string<charT, traits, Allocator>& lhs, charT rhs);                        // constexpr since C++20

template<class charT, class traits, class Allocator>
bool operator==(const basic_string<charT, traits, Allocator>& lhs,
                const basic_string<charT, traits, Allocator>& rhs) noexcept;                    // constexpr since C++20

template<class charT, class traits, class Allocator>
bool operator==(const charT* lhs, const basic_string<charT, traits, Allocator>& rhs) noexcept;  // constexpr since C++20

template<class charT, class traits, class Allocator>
bool operator==(const basic_string<charT,traits,Allocator>& lhs, const charT* rhs) noexcept;    // constexpr since C++20

template<class charT, class traits, class Allocator>
bool operator!=(const basic_string<charT,traits,Allocator>& lhs,
                const basic_string<charT, traits, Allocator>& rhs) noexcept;                    // constexpr since C++20

template<class charT, class traits, class Allocator>
bool operator!=(const charT* lhs, const basic_string<charT, traits, Allocator>& rhs) noexcept;  // constexpr since C++20

template<class charT, class traits, class Allocator>
bool operator!=(const basic_string<charT, traits, Allocator>& lhs, const charT* rhs) noexcept;  // constexpr since C++20

template<class charT, class traits, class Allocator>
bool operator< (const basic_string<charT, traits, Allocator>& lhs,
                const basic_string<charT, traits, Allocator>& rhs) noexcept;                    // constexpr since C++20

template<class charT, class traits, class Allocator>
bool operator< (const basic_string<charT, traits, Allocator>& lhs, const charT* rhs) noexcept;  // constexpr since C++20

template<class charT, class traits, class Allocator>
bool operator< (const charT* lhs, const basic_string<charT, traits, Allocator>& rhs) noexcept;  // constexpr since C++20

template<class charT, class traits, class Allocator>
bool operator> (const basic_string<charT, traits, Allocator>& lhs,
                const basic_string<charT, traits, Allocator>& rhs) noexcept;                    // constexpr since C++20

template<class charT, class traits, class Allocator>
bool operator> (const basic_string<charT, traits, Allocator>& lhs, const charT* rhs) noexcept;  // constexpr since C++20

template<class charT, class traits, class Allocator>
bool operator> (const charT* lhs, const basic_string<charT, traits, Allocator>& rhs) noexcept;  // constexpr since C++20

template<class charT, class traits, class Allocator>
bool operator<=(const basic_string<charT, traits, Allocator>& lhs,
                const basic_string<charT, traits, Allocator>& rhs) noexcept;                    // constexpr since C++20

template<class charT, class traits, class Allocator>
bool operator<=(const basic_string<charT, traits, Allocator>& lhs, const charT* rhs) noexcept;  // constexpr since C++20

template<class charT, class traits, class Allocator>
bool operator<=(const charT* lhs, const basic_string<charT, traits, Allocator>& rhs) noexcept;  // constexpr since C++20

template<class charT, class traits, class Allocator>
bool operator>=(const basic_string<charT, traits, Allocator>& lhs,
                const basic_string<charT, traits, Allocator>& rhs) noexcept;                    // constexpr since C++20

template<class charT, class traits, class Allocator>
bool operator>=(const basic_string<charT, traits, Allocator>& lhs, const charT* rhs) noexcept;  // constexpr since C++20

template<class charT, class traits, class Allocator>
bool operator>=(const charT* lhs, const basic_string<charT, traits, Allocator>& rhs) noexcept;  // constexpr since C++20

template<class charT, class traits, class Allocator>
void swap(basic_string<charT, traits, Allocator>& lhs,
          basic_string<charT, traits, Allocator>& rhs)
            noexcept(noexcept(lhs.swap(rhs)));                                                  // constexpr since C++20

template<class charT, class traits, class Allocator>
basic_istream<charT, traits>&
operator>>(basic_istream<charT, traits>& is, basic_string<charT, traits, Allocator>& str);

template<class charT, class traits, class Allocator>
basic_ostream<charT, traits>&
operator<<(basic_ostream<charT, traits>& os, const basic_string<charT, traits, Allocator>& str);

template<class charT, class traits, class Allocator>
basic_istream<charT, traits>&
getline(basic_istream<charT, traits>& is, basic_string<charT, traits, Allocator>& str,
        charT delim);

template<class charT, class traits, class Allocator>
basic_istream<charT, traits>&
getline(basic_istream<charT, traits>& is, basic_string<charT, traits, Allocator>& str);

template<class charT, class traits, class Allocator, class U>
typename basic_string<charT, traits, Allocator>::size_type
erase(basic_string<charT, traits, Allocator>& c, const U& value);    // C++20
template<class charT, class traits, class Allocator, class Predicate>
typename basic_string<charT, traits, Allocator>::size_type
erase_if(basic_string<charT, traits, Allocator>& c, Predicate pred); // C++20

typedef basic_string<char>    string;
typedef basic_string<wchar_t> wstring;
typedef basic_string<char8_t> u8string; // C++20
typedef basic_string<char16_t> u16string;
typedef basic_string<char32_t> u32string;

int                stoi  (const string& str, size_t* idx = nullptr, int base = 10);
long               stol  (const string& str, size_t* idx = nullptr, int base = 10);
unsigned long      stoul (const string& str, size_t* idx = nullptr, int base = 10);
long long          stoll (const string& str, size_t* idx = nullptr, int base = 10);
unsigned long long stoull(const string& str, size_t* idx = nullptr, int base = 10);

float       stof (const string& str, size_t* idx = nullptr);
double      stod (const string& str, size_t* idx = nullptr);
long double stold(const string& str, size_t* idx = nullptr);

string to_string(int val);
string to_string(unsigned val);
string to_string(long val);
string to_string(unsigned long val);
string to_string(long long val);
string to_string(unsigned long long val);
string to_string(float val);
string to_string(double val);
string to_string(long double val);

int                stoi  (const wstring& str, size_t* idx = nullptr, int base = 10);
long               stol  (const wstring& str, size_t* idx = nullptr, int base = 10);
unsigned long      stoul (const wstring& str, size_t* idx = nullptr, int base = 10);
long long          stoll (const wstring& str, size_t* idx = nullptr, int base = 10);
unsigned long long stoull(const wstring& str, size_t* idx = nullptr, int base = 10);

float       stof (const wstring& str, size_t* idx = nullptr);
double      stod (const wstring& str, size_t* idx = nullptr);
long double stold(const wstring& str, size_t* idx = nullptr);

wstring to_wstring(int val);
wstring to_wstring(unsigned val);
wstring to_wstring(long val);
wstring to_wstring(unsigned long val);
wstring to_wstring(long long val);
wstring to_wstring(unsigned long long val);
wstring to_wstring(float val);
wstring to_wstring(double val);
wstring to_wstring(long double val);

template <> struct hash<string>;
template <> struct hash<u8string>; // C++20
template <> struct hash<u16string>;
template <> struct hash<u32string>;
template <> struct hash<wstring>;

basic_string<char>     operator "" s( const char *str,     size_t len );           // C++14, constexpr since C++20
basic_string<wchar_t>  operator "" s( const wchar_t *str,  size_t len );           // C++14, constexpr since C++20
constexpr basic_string<char8_t>  operator "" s( const char8_t *str,  size_t len ); // C++20
basic_string<char16_t> operator "" s( const char16_t *str, size_t len );           // C++14, constexpr since C++20
basic_string<char32_t> operator "" s( const char32_t *str, size_t len );           // C++14, constexpr since C++20

}  // std

*/

#include <__algorithm/max.h>
#include <__algorithm/min.h>
#include <__algorithm/remove.h>
#include <__algorithm/remove_if.h>
#include <__assert> // all public C++ headers provide the assertion handler
#include <__config>
#include <__debug>
#include <__format/enable_insertable.h>
#include <__functional/hash.h>
#include <__functional/unary_function.h>
#include <__ios/fpos.h>
#include <__iterator/distance.h>
#include <__iterator/iterator_traits.h>
#include <__iterator/reverse_iterator.h>
#include <__iterator/wrap_iter.h>
#include <__memory/allocate_at_least.h>
#include <__memory/swap_allocator.h>
#include <__string/char_traits.h>
#include <__string/extern_template_lists.h>
#include <__utility/auto_cast.h>
#include <__utility/move.h>
#include <__utility/swap.h>
#include <__utility/unreachable.h>
#include <climits>
#include <cstdint>
#include <cstdio>  // EOF
#include <cstdlib>
#include <cstring>
#include <iosfwd>
#include <limits>
#include <memory>
#include <stdexcept>
#include <string_view>
#include <type_traits>
#include <version>

#ifndef _LIBCPP_HAS_NO_WIDE_CHARACTERS
#  include <cwchar>
#endif

#ifndef _LIBCPP_REMOVE_TRANSITIVE_INCLUDES
#  include <algorithm>
#  include <functional>
#  include <iterator>
#  include <new>
#  include <typeinfo>
#  include <utility>
#  include <vector>
#endif

// standard-mandated includes

// [iterator.range]
#include <__iterator/access.h>
#include <__iterator/data.h>
#include <__iterator/empty.h>
#include <__iterator/reverse_access.h>
#include <__iterator/size.h>

// [string.syn]
#include <compare>
#include <initializer_list>

#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
#  pragma GCC system_header
#endif

_LIBCPP_PUSH_MACROS
#include <__undef_macros>


_LIBCPP_BEGIN_NAMESPACE_STD

// basic_string

template<class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>
_LIBCPP_CONSTEXPR_AFTER_CXX17
operator+(const basic_string<_CharT, _Traits, _Allocator>& __x,
          const basic_string<_CharT, _Traits, _Allocator>& __y);

template<class _CharT, class _Traits, class _Allocator>
_LIBCPP_CONSTEXPR_AFTER_CXX17
basic_string<_CharT, _Traits, _Allocator>
operator+(const _CharT* __x, const basic_string<_CharT,_Traits,_Allocator>& __y);

template<class _CharT, class _Traits, class _Allocator>
_LIBCPP_CONSTEXPR_AFTER_CXX17
basic_string<_CharT, _Traits, _Allocator>
operator+(_CharT __x, const basic_string<_CharT,_Traits,_Allocator>& __y);

template<class _CharT, class _Traits, class _Allocator>
inline _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_AFTER_CXX17
basic_string<_CharT, _Traits, _Allocator>
operator+(const basic_string<_CharT, _Traits, _Allocator>& __x, const _CharT* __y);

template<class _CharT, class _Traits, class _Allocator>
_LIBCPP_CONSTEXPR_AFTER_CXX17
basic_string<_CharT, _Traits, _Allocator>
operator+(const basic_string<_CharT, _Traits, _Allocator>& __x, _CharT __y);

extern template _LIBCPP_FUNC_VIS string operator+<char, char_traits<char>, allocator<char> >(char const*, string const&);

template <class _Iter>
struct __string_is_trivial_iterator : public false_type {};

template <class _Tp>
struct __string_is_trivial_iterator<_Tp*>
    : public is_arithmetic<_Tp> {};

template <class _Iter>
struct __string_is_trivial_iterator<__wrap_iter<_Iter> >
    : public __string_is_trivial_iterator<_Iter> {};

template <class _CharT, class _Traits, class _Tp>
struct __can_be_converted_to_string_view : public _BoolConstant<
      is_convertible<const _Tp&, basic_string_view<_CharT, _Traits> >::value &&
     !is_convertible<const _Tp&, const _CharT*>::value
    > {};

#ifndef _LIBCPP_HAS_NO_CHAR8_T
typedef basic_string<char8_t> u8string;
#endif
typedef basic_string<char16_t> u16string;
typedef basic_string<char32_t> u32string;

struct __uninitialized_size_tag {};

template<class _CharT, class _Traits, class _Allocator>
class
    _LIBCPP_TEMPLATE_VIS
#ifndef _LIBCPP_HAS_NO_CHAR8_T
    _LIBCPP_PREFERRED_NAME(u8string)
#endif
    _LIBCPP_PREFERRED_NAME(u16string)
    _LIBCPP_PREFERRED_NAME(u32string)
    basic_string
{
public:
    typedef basic_string                                 __self;
    typedef basic_string_view<_CharT, _Traits>           __self_view;
    typedef _Traits                                      traits_type;
    typedef _CharT                                       value_type;
    typedef _Allocator                                   allocator_type;
    typedef allocator_traits<allocator_type>             __alloc_traits;
    typedef typename __alloc_traits::size_type           size_type;
    typedef typename __alloc_traits::difference_type     difference_type;
    typedef value_type&                                  reference;
    typedef const value_type&                            const_reference;
    typedef typename __alloc_traits::pointer             pointer;
    typedef typename __alloc_traits::const_pointer       const_pointer;

    static_assert((!is_array<value_type>::value), "Character type of basic_string must not be an array");
    static_assert(( is_standard_layout<value_type>::value), "Character type of basic_string must be standard-layout");
    static_assert(( is_trivial<value_type>::value), "Character type of basic_string must be trivial");
    static_assert(( is_same<_CharT, typename traits_type::char_type>::value),
                  "traits_type::char_type must be the same type as CharT");
    static_assert(( is_same<typename allocator_type::value_type, value_type>::value),
                  "Allocator::value_type must be same type as value_type");

    typedef __wrap_iter<pointer>                         iterator;
    typedef __wrap_iter<const_pointer>                   const_iterator;
    typedef std::reverse_iterator<iterator>              reverse_iterator;
    typedef std::reverse_iterator<const_iterator>        const_reverse_iterator;

private:
    static_assert(CHAR_BIT == 8, "This implementation assumes that one byte contains 8 bits");

#ifdef _LIBCPP_ABI_ALTERNATE_STRING_LAYOUT

    struct __long
    {
        pointer   __data_;
        size_type __size_;
        size_type __cap_ : sizeof(size_type) * CHAR_BIT - 1;
        size_type __is_long_ : 1;
    };

    enum {__min_cap = (sizeof(__long) - 1)/sizeof(value_type) > 2 ?
                      (sizeof(__long) - 1)/sizeof(value_type) : 2};

    struct __short
    {
        value_type __data_[__min_cap];
        unsigned char __padding_[sizeof(value_type) - 1];
        unsigned char __size_ : 7;
        unsigned char __is_long_ : 1;
    };

// The __endian_factor is required because the field we use to store the size
// has one fewer bit than it would if it were not a bitfield.
//
// If the LSB is used to store the short-flag in the short string representation,
// we have to multiply the size by two when it is stored and divide it by two when
// it is loaded to make sure that we always store an even number. In the long string
// representation, we can ignore this because we can assume that we always allocate
// an even amount of value_types.
//
// If the MSB is used for the short-flag, the max_size() is numeric_limits<size_type>::max() / 2.
// This does not impact the short string representation, since we never need the MSB
// for representing the size of a short string anyway.

#ifdef _LIBCPP_BIG_ENDIAN
    static const size_type __endian_factor = 2;
#else
    static const size_type __endian_factor = 1;
#endif

#else // _LIBCPP_ABI_ALTERNATE_STRING_LAYOUT

#ifdef _LIBCPP_BIG_ENDIAN
    static const size_type __endian_factor = 1;
#else
    static const size_type __endian_factor = 2;
#endif

    // Attribute 'packed' is used to keep the layout compatible with the
    // previous definition that did not use bit fields. This is because on
    // some platforms bit fields have a default size rather than the actual
    // size used, e.g., it is 4 bytes on AIX. See D128285 for details.
    struct __long
    {
        struct _LIBCPP_PACKED {
            size_type __is_long_ : 1;
            size_type __cap_ : sizeof(size_type) * CHAR_BIT - 1;
        };
        size_type __size_;
        pointer   __data_;
    };

    enum {__min_cap = (sizeof(__long) - 1)/sizeof(value_type) > 2 ?
                      (sizeof(__long) - 1)/sizeof(value_type) : 2};

    struct __short
    {
        struct _LIBCPP_PACKED {
            unsigned char __is_long_ : 1;
            unsigned char __size_ : 7;
        };
        char __padding_[sizeof(value_type) - 1];
        value_type __data_[__min_cap];
    };

#endif // _LIBCPP_ABI_ALTERNATE_STRING_LAYOUT

    static_assert(sizeof(__short) == (sizeof(value_type) * (__min_cap + 1)), "__short has an unexpected size.");

    union __ulx{__long __lx; __short __lxx;};

    enum {__n_words = sizeof(__ulx) / sizeof(size_type)};

    struct __raw
    {
        size_type __words[__n_words];
    };

    struct __rep
    {
        union
        {
            __long  __l;
            __short __s;
            __raw   __r;
        };
    };

    __compressed_pair<__rep, allocator_type> __r_;

    // Construct a string with the given allocator and enough storage to hold `__size` characters, but
    // don't initialize the characters. The contents of the string, including the null terminator, must be
    // initialized separately.
    _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_AFTER_CXX17
    explicit basic_string(__uninitialized_size_tag, size_type __size, const allocator_type& __a)
            : __r_(__default_init_tag(), __a) {
        if (__size > max_size())
            __throw_length_error();
        if (__fits_in_sso(__size)) {
            __zero();
            __set_short_size(__size);
        } else {
            auto __capacity = __recommend(__size) + 1;
            auto __allocation = __alloc_traits::allocate(__alloc(), __capacity);
            __begin_lifetime(__allocation, __capacity);
            __set_long_cap(__capacity);
            __set_long_pointer(__allocation);
            __set_long_size(__size);
        }
        std::__debug_db_insert_c(this);
    }

public:
    _LIBCPP_TEMPLATE_DATA_VIS
    static const size_type npos = -1;

    _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_AFTER_CXX17 basic_string()
        _NOEXCEPT_(is_nothrow_default_constructible<allocator_type>::value);

    _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_AFTER_CXX17 explicit basic_string(const allocator_type& __a)
#if _LIBCPP_STD_VER <= 14
        _NOEXCEPT_(is_nothrow_copy_constructible<allocator_type>::value);
#else
        _NOEXCEPT;
#endif

    _LIBCPP_CONSTEXPR_AFTER_CXX17 basic_string(const basic_string& __str);
    _LIBCPP_CONSTEXPR_AFTER_CXX17 basic_string(const basic_string& __str, const allocator_type& __a);

#ifndef _LIBCPP_CXX03_LANG
    _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_AFTER_CXX17
    basic_string(basic_string&& __str)
#if _LIBCPP_STD_VER <= 14
        _NOEXCEPT_(is_nothrow_move_constructible<allocator_type>::value);
#else
        _NOEXCEPT;
#endif

    _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_AFTER_CXX17
    basic_string(basic_string&& __str, const allocator_type& __a);
#endif // _LIBCPP_CXX03_LANG

    template <class = __enable_if_t<__is_allocator<_Allocator>::value, nullptr_t> >
    _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_AFTER_CXX17
    basic_string(const _CharT* __s) : __r_(__default_init_tag(), __default_init_tag()) {
      _LIBCPP_ASSERT(__s != nullptr, "basic_string(const char*) detected nullptr");
      __init(__s, traits_type::length(__s));
      std::__debug_db_insert_c(this);
    }

    template <class = __enable_if_t<__is_allocator<_Allocator>::value, nullptr_t> >
        _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_AFTER_CXX17
        basic_string(const _CharT* __s, const _Allocator& __a);

#if _LIBCPP_STD_VER > 20
    basic_string(nullptr_t) = delete;
#endif

    _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_AFTER_CXX17
    basic_string(const _CharT* __s, size_type __n);
    _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_AFTER_CXX17
    basic_string(const _CharT* __s, size_type __n, const _Allocator& __a);
    _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_AFTER_CXX17
    basic_string(size_type __n, _CharT __c);

    template <class = __enable_if_t<__is_allocator<_Allocator>::value, nullptr_t> >
        _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_AFTER_CXX17
        basic_string(size_type __n, _CharT __c, const _Allocator& __a);

    _LIBCPP_CONSTEXPR_AFTER_CXX17
    basic_string(const basic_string& __str, size_type __pos, size_type __n,
                 const _Allocator& __a = _Allocator());
    _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_AFTER_CXX17
    basic_string(const basic_string& __str, size_type __pos,
                 const _Allocator& __a = _Allocator());

    template<class _Tp, class = __enable_if_t<__can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value && !__is_same_uncvref<_Tp, basic_string>::value> >
        _LIBCPP_METHOD_TEMPLATE_IMPLICIT_INSTANTIATION_VIS _LIBCPP_CONSTEXPR_AFTER_CXX17
        basic_string(const _Tp& __t, size_type __pos, size_type __n,
                     const allocator_type& __a = allocator_type());

    template<class _Tp, class = __enable_if_t<__can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value &&
                                          !__is_same_uncvref<_Tp, basic_string>::value> >
        _LIBCPP_METHOD_TEMPLATE_IMPLICIT_INSTANTIATION_VIS _LIBCPP_CONSTEXPR_AFTER_CXX17
        explicit basic_string(const _Tp& __t);

    template<class _Tp, class = __enable_if_t<__can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value && !__is_same_uncvref<_Tp, basic_string>::value> >
        _LIBCPP_METHOD_TEMPLATE_IMPLICIT_INSTANTIATION_VIS _LIBCPP_CONSTEXPR_AFTER_CXX17
        explicit basic_string(const _Tp& __t, const allocator_type& __a);

    template<class _InputIterator, class = __enable_if_t<__is_cpp17_input_iterator<_InputIterator>::value> >
        _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_AFTER_CXX17
        basic_string(_InputIterator __first, _InputIterator __last);
    template<class _InputIterator, class = __enable_if_t<__is_cpp17_input_iterator<_InputIterator>::value> >
        _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_AFTER_CXX17
        basic_string(_InputIterator __first, _InputIterator __last, const allocator_type& __a);
#ifndef _LIBCPP_CXX03_LANG
    _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_AFTER_CXX17
    basic_string(initializer_list<_CharT> __il);
    _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_AFTER_CXX17
    basic_string(initializer_list<_CharT> __il, const _Allocator& __a);
#endif // _LIBCPP_CXX03_LANG

    inline _LIBCPP_CONSTEXPR_AFTER_CXX17 ~basic_string();

    _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_AFTER_CXX17
    operator __self_view() const _NOEXCEPT { return __self_view(data(), size()); }

    _LIBCPP_CONSTEXPR_AFTER_CXX17 basic_string& operator=(const basic_string& __str);

    template <class _Tp, class = __enable_if_t<__can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value &&
                                               !__is_same_uncvref<_Tp, basic_string>::value> >
    _LIBCPP_CONSTEXPR_AFTER_CXX17 basic_string& operator=(const _Tp& __t) {
      __self_view __sv = __t;
      return assign(__sv);
    }

#ifndef _LIBCPP_CXX03_LANG
    _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_AFTER_CXX17
    basic_string& operator=(basic_string&& __str)
        _NOEXCEPT_((__noexcept_move_assign_container<_Allocator, __alloc_traits>::value));
     _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_AFTER_CXX17
    basic_string& operator=(initializer_list<value_type> __il) {return assign(__il.begin(), __il.size());}
#endif
    _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_AFTER_CXX17
    basic_string& operator=(const value_type* __s) {return assign(__s);}
#if _LIBCPP_STD_VER > 20
    basic_string& operator=(nullptr_t) = delete;
#endif
    _LIBCPP_CONSTEXPR_AFTER_CXX17 basic_string& operator=(value_type __c);

    _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_AFTER_CXX17
    iterator begin() _NOEXCEPT
        {return iterator(this, __get_pointer());}
    _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_AFTER_CXX17
    const_iterator begin() const _NOEXCEPT
        {return const_iterator(this, __get_pointer());}
    _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_AFTER_CXX17
    iterator end() _NOEXCEPT
        {return iterator(this, __get_pointer() + size());}
    _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_AFTER_CXX17
    const_iterator end() const _NOEXCEPT
        {return const_iterator(this, __get_pointer() + size());}

    _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_AFTER_CXX17
    reverse_iterator rbegin() _NOEXCEPT
        {return reverse_iterator(end());}
    _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_AFTER_CXX17
    const_reverse_iterator rbegin() const _NOEXCEPT
        {return const_reverse_iterator(end());}
    _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_AFTER_CXX17
    reverse_iterator rend() _NOEXCEPT
        {return reverse_iterator(begin());}
    _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_AFTER_CXX17
    const_reverse_iterator rend() const _NOEXCEPT
        {return const_reverse_iterator(begin());}

    _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_AFTER_CXX17
    const_iterator cbegin() const _NOEXCEPT
        {return begin();}
    _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_AFTER_CXX17
    const_iterator cend() const _NOEXCEPT
        {return end();}
    _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_AFTER_CXX17
    const_reverse_iterator crbegin() const _NOEXCEPT
        {return rbegin();}
    _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_AFTER_CXX17
    const_reverse_iterator crend() const _NOEXCEPT
        {return rend();}

    _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_AFTER_CXX17 size_type size() const _NOEXCEPT
        {return __is_long() ? __get_long_size() : __get_short_size();}
    _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_AFTER_CXX17 size_type length() const _NOEXCEPT {return size();}
    _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_AFTER_CXX17 size_type max_size() const _NOEXCEPT;
    _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_AFTER_CXX17 size_type capacity() const _NOEXCEPT {
        return (__is_long() ? __get_long_cap() : static_cast<size_type>(__min_cap)) - 1;
    }

    _LIBCPP_CONSTEXPR_AFTER_CXX17 void resize(size_type __n, value_type __c);
    _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_AFTER_CXX17 void resize(size_type __n) { resize(__n, value_type()); }

    _LIBCPP_CONSTEXPR_AFTER_CXX17 void reserve(size_type __requested_capacity);

#if _LIBCPP_STD_VER > 20
    template <class _Op>
    _LIBCPP_HIDE_FROM_ABI constexpr
    void resize_and_overwrite(size_type __n, _Op __op) {
      __resize_default_init(__n);
      __erase_to_end(std::move(__op)(data(), _LIBCPP_AUTO_CAST(__n)));
    }
#endif

    _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_AFTER_CXX17 void __resize_default_init(size_type __n);

    _LIBCPP_DEPRECATED_IN_CXX20 _LIBCPP_HIDE_FROM_ABI void reserve() _NOEXCEPT { shrink_to_fit(); }
    _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_AFTER_CXX17 void shrink_to_fit() _NOEXCEPT;
    _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_AFTER_CXX17 void clear() _NOEXCEPT;

    _LIBCPP_NODISCARD_AFTER_CXX17 _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_AFTER_CXX17
    bool empty() const _NOEXCEPT {return size() == 0;}

    _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_AFTER_CXX17
    const_reference operator[](size_type __pos) const _NOEXCEPT;
    _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_AFTER_CXX17 reference operator[](size_type __pos) _NOEXCEPT;

    _LIBCPP_CONSTEXPR_AFTER_CXX17 const_reference at(size_type __n) const;
    _LIBCPP_CONSTEXPR_AFTER_CXX17 reference       at(size_type __n);

    _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_AFTER_CXX17 basic_string& operator+=(const basic_string& __str) {
        return append(__str);
    }

    template <class _Tp>
    _LIBCPP_METHOD_TEMPLATE_IMPLICIT_INSTANTIATION_VIS _LIBCPP_CONSTEXPR_AFTER_CXX17
    __enable_if_t
        <
            __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value
            && !__is_same_uncvref<_Tp, basic_string >::value,
            basic_string&
        >
    operator+=(const _Tp& __t) {
        __self_view __sv = __t; return append(__sv);
    }

    _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_AFTER_CXX17 basic_string& operator+=(const value_type* __s) {
        return append(__s);
    }

    _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_AFTER_CXX17 basic_string& operator+=(value_type __c) {
        push_back(__c);
        return *this;
    }

#ifndef _LIBCPP_CXX03_LANG
    _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_AFTER_CXX17
    basic_string& operator+=(initializer_list<value_type> __il) { return append(__il); }
#endif // _LIBCPP_CXX03_LANG

    _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_AFTER_CXX17
    basic_string& append(const basic_string& __str);

    template <class _Tp>
    _LIBCPP_METHOD_TEMPLATE_IMPLICIT_INSTANTIATION_VIS _LIBCPP_CONSTEXPR_AFTER_CXX17
    __enable_if_t<
            __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value
            && !__is_same_uncvref<_Tp, basic_string>::value,
            basic_string&
        >
                  append(const _Tp& __t) { __self_view __sv = __t; return append(__sv.data(), __sv.size()); }
    _LIBCPP_CONSTEXPR_AFTER_CXX17 basic_string& append(const basic_string& __str, size_type __pos, size_type __n=npos);

    template <class _Tp>
    _LIBCPP_METHOD_TEMPLATE_IMPLICIT_INSTANTIATION_VIS _LIBCPP_CONSTEXPR_AFTER_CXX17
    __enable_if_t
        <
            __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value
            && !__is_same_uncvref<_Tp, basic_string>::value,
            basic_string&
        >
                  append(const _Tp& __t, size_type __pos, size_type __n=npos);
    _LIBCPP_CONSTEXPR_AFTER_CXX17 basic_string& append(const value_type* __s, size_type __n);
    _LIBCPP_CONSTEXPR_AFTER_CXX17 basic_string& append(const value_type* __s);
    _LIBCPP_CONSTEXPR_AFTER_CXX17 basic_string& append(size_type __n, value_type __c);

    _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_AFTER_CXX17
    void __append_default_init(size_type __n);

    template<class _InputIterator>
    _LIBCPP_METHOD_TEMPLATE_IMPLICIT_INSTANTIATION_VIS
    __enable_if_t
        <
            __is_exactly_cpp17_input_iterator<_InputIterator>::value,
            basic_string&
        >
    _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_AFTER_CXX17
    append(_InputIterator __first, _InputIterator __last) {
      const basic_string __temp(__first, __last, __alloc());
      append(__temp.data(), __temp.size());
      return *this;
    }
    template<class _ForwardIterator>
    _LIBCPP_METHOD_TEMPLATE_IMPLICIT_INSTANTIATION_VIS
    __enable_if_t
        <
            __is_cpp17_forward_iterator<_ForwardIterator>::value,
            basic_string&
        >
    _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_AFTER_CXX17
    append(_ForwardIterator __first, _ForwardIterator __last);

#ifndef _LIBCPP_CXX03_LANG
    _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_AFTER_CXX17
    basic_string& append(initializer_list<value_type> __il) {return append(__il.begin(), __il.size());}
#endif // _LIBCPP_CXX03_LANG

    _LIBCPP_CONSTEXPR_AFTER_CXX17 void push_back(value_type __c);
    _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_AFTER_CXX17 void pop_back();
    _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_AFTER_CXX17 reference       front() _NOEXCEPT;
    _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_AFTER_CXX17 const_reference front() const _NOEXCEPT;
    _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_AFTER_CXX17 reference       back() _NOEXCEPT;
    _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_AFTER_CXX17 const_reference back() const _NOEXCEPT;

    template <class _Tp>
    _LIBCPP_METHOD_TEMPLATE_IMPLICIT_INSTANTIATION_VIS _LIBCPP_CONSTEXPR_AFTER_CXX17
    __enable_if_t
        <
            __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,
            basic_string&
        >
                 assign(const _Tp & __t) { __self_view __sv = __t; return assign(__sv.data(), __sv.size()); }
    _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_AFTER_CXX17
    basic_string& assign(const basic_string& __str) { return *this = __str; }
#ifndef _LIBCPP_CXX03_LANG
    _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_AFTER_CXX17
    basic_string& assign(basic_string&& __str)
        _NOEXCEPT_((__noexcept_move_assign_container<_Allocator, __alloc_traits>::value))
        {*this = std::move(__str); return *this;}
#endif
    _LIBCPP_CONSTEXPR_AFTER_CXX17 basic_string& assign(const basic_string& __str, size_type __pos, size_type __n=npos);
    template <class _Tp>
    _LIBCPP_METHOD_TEMPLATE_IMPLICIT_INSTANTIATION_VIS _LIBCPP_CONSTEXPR_AFTER_CXX17
    __enable_if_t
        <
            __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value
            && !__is_same_uncvref<_Tp, basic_string>::value,
            basic_string&
        >
                  assign(const _Tp & __t, size_type __pos, size_type __n=npos);
    _LIBCPP_CONSTEXPR_AFTER_CXX17 basic_string& assign(const value_type* __s, size_type __n);
    _LIBCPP_CONSTEXPR_AFTER_CXX17 basic_string& assign(const value_type* __s);
    _LIBCPP_CONSTEXPR_AFTER_CXX17 basic_string& assign(size_type __n, value_type __c);
    template<class _InputIterator>
    _LIBCPP_METHOD_TEMPLATE_IMPLICIT_INSTANTIATION_VIS _LIBCPP_CONSTEXPR_AFTER_CXX17
    __enable_if_t
        <
            __is_exactly_cpp17_input_iterator<_InputIterator>::value,
            basic_string&
        >
        assign(_InputIterator __first, _InputIterator __last);
    template<class _ForwardIterator>
    _LIBCPP_METHOD_TEMPLATE_IMPLICIT_INSTANTIATION_VIS _LIBCPP_CONSTEXPR_AFTER_CXX17
    __enable_if_t
        <
            __is_cpp17_forward_iterator<_ForwardIterator>::value,
            basic_string&
        >
        assign(_ForwardIterator __first, _ForwardIterator __last);
#ifndef _LIBCPP_CXX03_LANG
    _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_AFTER_CXX17
    basic_string& assign(initializer_list<value_type> __il) {return assign(__il.begin(), __il.size());}
#endif // _LIBCPP_CXX03_LANG

    _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_AFTER_CXX17
    basic_string& insert(size_type __pos1, const basic_string& __str);

    template <class _Tp>
    _LIBCPP_METHOD_TEMPLATE_IMPLICIT_INSTANTIATION_VIS _LIBCPP_CONSTEXPR_AFTER_CXX17
    __