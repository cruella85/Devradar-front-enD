// -*- C++ -*-
//===----------------------------------------------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//

#ifndef _LIBCPP_STRING
#define _LIBCPP_STRING

/*
    string synopsis

namespace std
{

template <class stateT>
class fpos
{
private:
    stateT st;
public:
    fpos(streamoff = streamoff());

    operator streamoff() const;

    stateT state() const;
    void state(stateT);

    fpos& operator+=(streamoff);
    fpos  operator+ (streamoff) const;
    fpos& operator-=(streamoff);
    fpos  operator- (streamoff) const;
};

template <class stateT> streamoff operator-(const fpos<stateT>& x, const fpos<stateT>& y);

template <class stateT> bool operator==(const fpos<stateT>& x, const fpos<stateT>& y);
template <class stateT> bool operator!=(const fpos<stateT>& x, const fpos<stateT>& y);

template <class charT>
struct char_traits
{
    typedef charT     char_type;
    typedef ...       int_type;
    typedef streamoff off_type;
    typedef streampos pos_type;
    typedef mbstate_t state_type;

    static void assign(char_type& c1, const char_type& c2) noexcept;
    static constexpr bool eq(char_type c1, char_type c2) noexcept;
    static constexpr bool lt(char_type c1, char_type c2) noexcept;

    static int              compare(const char_type* s1, const char_type* s2, size_t n);
    static size_t           length(const char_type* s);
    static const char_type* find(const char_type* s, size_t n, const char_type& a);
    static char_type*       move(char_type* s1, const char_type* s2, size_t n);
    static char_type*       copy(char_type* s1, const char_type* s2, size_t n);
    static char_type*       assign(char_type* s, size_t n, char_type a);

    static constexpr int_type  not_eof(int_type c) noexcept;
    static constexpr char_type to_char_type(int_type c) noexcept;
    static constexpr int_type  to_int_type(char_type c) noexcept;
    static constexpr bool      eq_int_type(int_type c1, int_type c2) noexcept;
    static constexpr int_type  eof() noexcept;
};

template <> struct char_traits<char>;
template <> struct char_traits<wchar_t>;
template <> struct char_traits<char8_t>;  // C++20
template <> struct char_traits<char16_t>;
template <> struct char_traits<char32_t>;

template<class charT, class traits = char_traits<charT>, class Allocator = allocator<charT> >
class basic_string
{
public:
// types:
    typedef traits traits_type;
    typedef typename traits_type::char_type value_type;
    typedef Allocator allocator_type;
    typedef typename allocator_type::size_type size_type;
    typedef typename allocator_type::difference_type difference_type;
    typedef typename allocator_type::reference reference;
    typedef typename allocator_type::const_reference const_reference;
    typedef typename allocator_type::pointer pointer;
    typedef typename allocator_type::const_pointer const_pointer;
    typedef implementation-defined iterator;
    typedef implementation-defined const_iterator;
    typedef std::reverse_iterator<iterator> reverse_iterator;
    typedef std::reverse_iterator<const_iterator> const_reverse_iterator;

    static const size_type npos = -1;

    basic_string()
        noexcept(is_nothrow_default_constructible<allocator_type>::value);                      // constexpr since C++20
    explicit basic_string(const allocator_type& a);                                             // constexpr since C++20
    basic_string(const basic_string& str);                                                      // constexpr since C++20
    basic_string(basic_string&& str)
        noexcept(is_nothrow_move_constructible<allocator_type>::value);                         // constexpr since C++20
    basic_string(const basic_string& str, size_type pos,
                 const allocator_type& a = allocator_type());                                   // constexpr since C++20
    basic_string(const basic_string& str, size_type pos, size_type n,
                 const Allocator& a = Allocator());                                             // constexpr since C++20
    template<class T>
        basic_string(const T& t, size_type pos, size_type n, const Allocator& a = Allocator()); // C++17, constexpr since C++20
    template <class T>
        explicit basic_string(const T& t, const Allocator& a = Allocator());                    // C++17, constexpr since C++20
    basic_string(const value_type* s, const allocator_type& a = allocator_type());              // constexpr since C++20
    basic_string(const value_type* s, size_type n, const allocator_type& a = allocator_type()); // constexpr since C++20
    basic_string(nullptr_t) = delete; // C++2b
    basic_string(size_type n, value_type c, const allocator_type& a = allocator_type());        // constexpr since C++20
    template<class InputIterator>
        basic_string(InputIterator begin, InputIterator end,
                     const allocator_type& a = allocator_type());                               // constexpr since C++20
    basic_string(initializer_list<value_type>, const Allocator& = Allocator());                 // constexpr since C++20
    basic_string(const basic_string&, const Allocator&);                                        // constexpr since C++20
    basic_string(basic_string&&, const Allocator&);                                             // constexpr since C++20

    ~basic_string();                                                                            // constexpr since C++20

    operator basic_string_view<charT, traits>() const noexcept;                                 // constexpr since C++20

    basic_string& operator=(const basic_string& str);                                           // constexpr since C++20
    template <class T>
        basic_string& operator=(const T& t);                                                    // C++17, constexpr since C++20
    basic_string& operator=(basic_string&& str)
        noexcept(
             allocator_type::propagate_on_container_move_assignment::value ||
             allocator_type::is_always_equal::value );                                          // C++17, constexpr since C++20
    basic_string& operator=(const value_type* s);                                               // constexpr since C++20
    basic_string& operator=(nullptr_t) = delete; // C++2b
    basic_string& operator=(value_type c);                                                      // constexpr since C++20
    basic_string& operator=(initializer_list<value_type>);                                      // constexpr since C++20

    iterator       begin() noexcept;                                                            // constexpr since C++20
    const_iterator begin() const noexcept;                                                      // constexpr since C++20
    iterator       end() noexcept;                                                              // constexpr since C++20
    const_iterator end() const noexcept;                                                        // constexpr since C++20

    reverse_iterator       rbegin() noexcept;                                                   // constexpr since C++20
    const_reverse_iterator rbegin() const noexcept;                                             // constexpr since C++20
    reverse_iterator       rend() noexcept;                                                     // constexpr since C++20
    const_reverse_iterator rend() const noexcept;                                               // constexpr since C++20

    const_iterator         cbegin() const noexcept;                                             // constexpr since C++20
    const_iterator         cend() const noexcept;                                               // constexpr since C++20
    const_reverse_iterator crbegin() const noexcept;                                            // constexpr since C++20
    const_reverse_iterator crend() const noexcept;                                              // constexpr since C++20

    size_type size() const noexcept;                                                            // constexpr since C++20
    size_type length() const noexcept;                                                          // constexpr since C++20
    size_type max_size() const noexcept;                                                        // constexpr since C++20
    size_type capacity() const noexcept;                                                        // constexpr since C++20

    void resize(size_type n, value_type c);                                                     // constexpr since C++20
    void resize(size_type n);                                                                   // constexpr since C++20

    template<class Operation>
    constexpr void resize_and_overwrite(size_type n, Operation op); // since C++23

    void reserve(size_type res_arg);                                                            // constexpr since C++20
    void reserve(); // deprecated in C++20
    void shrink_to_fit();                                                                       // constexpr since C++20
    void clear() noexcept;                                                                      // constexpr since C++20
    bool empty() const noexcept;                                                                // constexpr since C++20

    const_reference operator[](size_type pos) const;                                            // constexpr since C++20
    reference       operator[](size_type pos);                                                  // constexpr since C++20

    const_reference at(size_type n) const;                                                      // constexpr since C++20
    reference       at(size_type n);                                                            // constexpr since C++20

    basic_string& operator+=(const basic_string& str);                                          // constexpr since C++20
    template <class T>
        basic_string& operator+=(const T& t);                                                   // C++17, constexpr since C++20
    basic_string& operator+=(const value_type* s);                                              // constexpr since C++20
    basic_string& operator+=(value_type c);                                                     // constexpr since C++20
    basic_string& operator+=(initializer_list<value_type>);                                     // constexpr since C++20

    basic_string& append(const basic_string& str);                                              // constexpr since C++20
    template <class T>
        basic_string& append(const T& t);                                                       // C++17, constexpr since C++20
    basic_string& append(const basic_string& str, size_type pos, size_type n=npos);             // C++14, constexpr since C++20
    template <class T>
        basic_string& append(const T& t, size_type pos, size_type n=npos);                      // C++17, constexpr since C++20
    basic_string& append(const value_type* s, size_type n);                                     // constexpr since C++20
    basic_string& append(const value_type* s);                                                  // constexpr since C++20
    basic_string& append(size_type n, value_type c);                                            // constexpr since C++20
    template<class InputIterator>
        basic_string& append(InputIterator first, InputIterator last);                          // constexpr since C++20
    basic_string& append(initializer_list<value_type>);                                         // constexpr since C++20

    void push_back(value_type c);                                                               // constexpr since C++20
    void pop_back();                                                                            // constexpr since C++20
    reference       front();                                                                    // constexpr since C++20
    const_reference front() const;                                                              // constexpr since C++20
    reference       back();                                                                     // constexpr since C++20
    const_reference back() const;                                                               // constexpr since C++20

    basic_string& assign(const basic_string& str);                                              // constexpr since C++20
    template <class T>
        basic_string& assign(const T& t);                                                       // C++17, constexpr since C++20
    basic_string& assign(basic_string&& str);                                                   // constexpr since C++20
    basic_string& assign(const basic_string& str, size_type pos, size_type n=npos);             // C++14, constexpr since C++20
    template <class T>
        basic_string& assign(const T& t, size_type pos, size_type n=npos);                      // C++17, constexpr since C++20
    basic_string& assign(const value_type* s, size_type n);                                     // constexpr since C++20
    basic_string& assign(const value_type* s);                                                  // constexpr since C++20
    basic_string& assign(size_type n, value_type c);                                            // constexpr since C++20
    template<class InputIterator>
        basic_string& assign(InputIterator first, InputIterator last);                          // constexpr since C++20
    basic_string& assign(initializer_list<value_type>);                                         // constexpr since C++20

    basic_string& insert(size_type pos1, const basic_string& str);                              // constexpr since C++20
    template <class T>
        basic_string& insert(size_type pos1, const T& t);                                       // constexpr since C++20
    basic_string& insert(size_type pos1, const basic_string& str,
                         size_type pos2, size_type n);                                          // constexpr since C++20
    template <class T>
        basic_string& insert(size_type pos1, const T& t, size_type pos2, size_type n);          // C++17, constexpr since C++20
    basic_string& insert(size_type pos, const value_type* s, size_type n=npos);                 // C++14, constexpr since C++20
    basic_string& insert(size_type pos, const value_type* s);                                   // constexpr since C++20
    basic_string& insert(size_type pos, size_type n, value_type c);                             // constexpr since C++20
    iterator      insert(const_iterator p, value_type c);                                       // constexpr since C++20
    iterator      insert(const_iterator p, size_type n, value_type c);                          // constexpr since C++20
    template<class InputIterator>
        iterator insert(const_iterator p, InputIterator first, InputIterator last);             // constexpr since C++20
    iterator      insert(const_iterator p, initializer_list<value_type>);                       // constexpr since C++20

    basic_string& erase(size_type pos = 0, size_type n = npos);                                 // constexpr since C++20
    iterator      erase(const_iterator position);                                               // constexpr since C++20
    iterator      erase(const_iterator first, const_iterator last);                             // constexpr since C++20

    basic_string& replace(size_type pos1, size_type n1, const basic_string& str);               // constexpr since C++20
    template <class T>
    basic_string& replace(size_type pos1, size_type n1, const T& t);                            // C++17, constexpr since C++20
    basic_string& replace(size_type pos1, size_type n1, const basic_string& str,
                          size_type pos2, size_type n2=npos);                                   // C++14, constexpr since C++20
    template <class T>
        basic_string& replace(size_type pos1, size_type n1, const T& t,
                              size_type pos2, size_type n);                                     // C++17, constexpr since C++20
    basic_string& replace(size_type pos, size_type n1, const value_type* s, size_type n2);      // constexpr since C++20
    basic_string& replace(size_type pos, size_type n1, const value_type* s);                    // constexpr since C++20
    basic_string& replace(size_type pos, size_type n1, size_type n2, value_type c);             // constexpr since C++20
    basic_string& replace(const_iterator i1, const_iterator i2, const basic_string& str);       // constexpr since C++20
    template <class T>
        basic_string& replace(const_iterator i1, const_iterator i2, const T& t);                // C++17, constexpr since C++20
    basic_string& replace(const_iterator i1, const_iterator i2, const value_type* s, size_type n); // constexpr since C++20
    basic_string& replace(const_iterator i1, const_iterator i2, const value_type* s);           // constexpr since C++20
    basic_string& replace(const_iterator i1, const_iterator i2, size_type n, value_type c);     // constexpr since C++20
    template<class InputIterator>
        basic_string& replace(const_iterator i1, const_iterator i2, InputIterator j1, InputIterator j2); // constexpr since C++20
    basic_string& replace(const_iterator i1, const_iterator i2, initializer_list<value_type>);  // constexpr since C++20

    size_type copy(value_type* s, size_type n, size_type pos = 0) const;                        // constexpr since C++20
    basic_string substr(size_type pos = 0, size_type n = npos) const;                           // constexpr since C++20

    void swap(basic_string& str)
        noexcept(allocator_traits<allocator_type>::propagate_on_container_swap::value ||
                 allocator_traits<allocator_type>::is_always_equal::value);                     // C++17, constexpr since C++20

    const value_type* c_str() const noexcept;                                                   // constexpr since C++20
    const value_type* data() const noexcept;                                                    // constexpr since C++20
          value_type* data()       noexcept;                                                    // C++17, constexpr since C++20

    allocator_type get_allocator() const noexcept;                                              // constexpr since C++20

    size_type find(const basic_string& str, size_type pos = 0) const noexcept;                  // constexpr since C++20
    template <class T>
        size_type find(const T& t, size_type pos = 0) const noexcept;                           // C++17, noexcept as an extension, constexpr since C++20
    size_type find(const value_type* s, size_type pos, size_type n) const noexcept;             // constexpr since C++20
    size_type find(const value_type* s, size_type pos = 0) const noexcept;                      // constexpr since C++20
    size_type find(value_type c, size_type pos = 0) const noexcept;                             // constexpr since C++20

    size_type rfind(const basic_string& str, size_type pos = npos) const noexcept;              // constexpr since C++20
    template <class T>
        size_type rfind(const T& t, size_type pos = npos) const noexcept;                       // C++17, noexcept as an extension, constexpr since C++20
    size_type rfind(const value_type* s, size_type pos, size_type n) const noexcept;            // constexpr since C++20
    size_type rfind(const value_type* s, size_type pos = npos) const noexcept;                  // constexpr since C++20
    size_type rfind(value_type c, size_type pos = npos) const noexcept;                         // constexpr since C++20

    size_type find_first_of(const basic_string& str, size_type pos = 0) const noexcept;         // constexpr since C++20
    template <class T>
        size_type find_first_of(const T& t, size_type pos = 0) const noexcept;                  // C++17, noexcept as an extension, constexpr since C++20
    size_type find_first_of(const value_type* s, size_type pos, size_type n) const noexcept;    // constexpr since C++20
    size_type find_first_of(const value_type* s, size_type pos = 0) const noexcept;             // constexpr since C++20
    size_type find_first_of(value_type c, size_type pos = 0) const noexcept;                    // constexpr since C++20

    size_type find_last_of(const basic_string& str, size_type pos = npos) const noexcept;       // constexpr since C++20
    template <class T>
        size_type find_last_of(const T& t, size_type pos = npos) const noexcept noexcept;       // C++17, noexcept as an extension, constexpr since C++20
    size_type find_last_of(const value_type* s, size_type pos, size_type n) const noexcept;     // constexpr since C++20
    size_type find_last_of(const value_type* s, size_type pos = npos) const noexcept;           // constexpr since C++20
    size_type find_last_of(value_type c, size_type pos = npos) const noexcept;                  // constexpr since C++20

    size_type find_first_not_of(const basic_string& str, size_type pos = 0) const noexcept;     // constexpr since C++20
    template <class T>
        size_type find_first_not_of(const T& t, size_type pos = 0) const noexcept;              // C++17, noexcept as an extension, constexpr since C++20
    size_type find_first_not_of(const value_type* s, size_type pos, size_type n) const noexcept; // constexpr since C++20
    size_type find_first_not_of(const value_type* s, size_type pos = 0) const noexcept;         // constexpr since C++20
    size_type find_first_not_of(value_type c, size_type pos = 0) const noexcept;                // constexpr since C++20

    size_type find_last_not_of(const basic_string& str, size_type pos = npos) const noexcept;   // constexpr since C++20
    template <class T>
        size_type find_last_not_of(const T& t, size_type pos = npos) const noexcept;            // C++17, noexcept as an extension, constexpr since C++20
    size_type find_last_not_of(const value_type* s, size_type pos, size_type n) const noexcept; // constexpr since C++20
    size_type find_last_not_of(const value_type* s, size_type pos = npos) const noexcept;       // constexpr since C++20
    size_type find_last_not_of(value_type c, size_type pos = npos) const noexcept;              // constexpr since C++20

    int compare(const basic_string& str) const noexcept;                                        // constexpr since C++20
    template <class T>
        int compare(const T& t) const noexcept;                                                 // C++17, noexcept as an extension, constexpr since C++20
    int compare(size_type pos1, size_type n1, const basic_string& str) const;                   // constexpr since C++20
    template <class T>
        int compare(size_type pos1, size_type n1, const T& t) const;                            // C++17, constexpr since C++20
    int compare(size_type pos1, size_type n1, const basic_string& str,
                size_type pos2, size_type n2=npos) const;                                       // C++14, constexpr since C++20
    template <class T>
        int compare(size_type pos1, size_type n1, const T& t,
                    size_type pos2, size_type n2=npos) const;                                   // C++17, constexpr since C++20
    int compare(const value_type* s) const noexcept;                                            // constexpr since C++20
    int compare(size_type pos1, size_type n1, const value_type* s) const;                       // constexpr since C++20
    int compare(size_type pos1, size_type n1, const value_type* s, size_type n2) const;         // constexpr since C++20

    constexpr bool starts_with(basic_string_view<charT, traits> sv) const noexcept;             // C++20
    constexpr bool starts_with(charT c) const noexcept;                                         // C++20
    constexpr bool starts_with(const charT* s) const;                                           // C++20
    constexpr bool ends_with(basic_string_view<charT, traits> sv) const noexcept;               // C++20
    constexpr bool ends_with(charT c) const noexcept;                                           // C++20
    constexpr bool ends_with(const charT* s) const;                                             // C++20

    constexpr bool contains(basic_string_view<charT, traits> sv) const noexcept;                // C++2b
    constexpr bool contains(charT c) const noexcept;                                            // C++2b
    constexpr bool contains(const charT* s) const;                                              // C++2b
};

template<class InputIterator,
         class Allocator = allocator<typename iterator_traits<InputIterator>::value_type>>
basic_string(InputIterator, InputIterator, Allocator = Allocator())
   -> basic_string<typename iterator_traits<InputIterator>::value_type,
                  char_traits<typename iterator_traits<InputIterator>::value_type>,
                  Allocator>;   // C++17

template<class charT, class traits, class Allocator>
basic_string<charT, traits, Allocator>
operator+(const basic_string<charT, traits, Allocator>& lhs,
          const basic_string<charT, traits, Allocator>& rhs);                                   // constexpr since C++20

template<class charT, class traits, class Allocator>
basic_string<charT, traits, Allocator>
operator+(const charT* lhs , const basic_string<charT,traits,Allocator>&rhs);                   // constexpr since C++20

template<class charT, class traits, class Allocator>
basic_string<charT, traits, Allocator>
operator+(charT lhs, const basic_string<charT,traits,Allocator>& rhs);                          // constexpr since C++20

template<class charT, class traits, class Allocator>
basic_string<charT, traits, Allocator>
operator+(const basic_string<charT, traits, Allocator>& lhs, const charT* rhs);                 // constexpr since C++20

template<class charT, class traits, class Allocator>
basic_string<charT, traits, Allocator>
operator+(const basic_string<charT, traits, Allocator>& lhs, charT rhs);                        // constexpr since C++20

template<class charT, class traits, class Allocator>
bool operator==(const basic_string<charT, traits, Allocator>& lhs,
                const basic_string<charT, traits, Allocator>& rhs) noexcept;                    // constexpr since C++20

template<class charT, class traits, class Allocator>
bool operator==(const charT* lhs, const basic_string<charT, traits, Allocator>& rhs) noexcept;  // constexpr since C++20

template<class charT, class traits, class Allocator>
bool operator==(const basic_string<charT,traits,Allocator>& lhs, const charT* rhs) noexcept;    // constexpr since C++20

template<class charT, class traits, class Allocator>
bool operator!=(const basic_string<charT,traits,Allocator>& lhs,
                const basic_string<charT, traits, Allocator>& rhs) noexcept;                    // constexpr since C++20

template<class charT, class traits, class Allocator>
bool operator!=(const charT* lhs, const basic_string<charT, traits, Allocator>& rhs) noexcept;  // constexpr since C++20

template<class charT, class traits, class Allocator>
bool operator!=(const basic_string<charT, traits, Allocator>& lhs, const charT* rhs) noexcept;  // constexpr since C++20

template<class charT, class traits, class Allocator>
bool operator< (const basic_string<charT, traits, Allocator>& lhs,
                const basic_string<charT, traits, Allocator>& rhs) noexcept;                    // constexpr since C++20

template<class charT, class traits, class Allocator>
bool operator< (const basic_string<charT, traits, Allocator>& lhs, const charT* rhs) noexcept;  // constexpr since C++20

template<class charT, class traits, class Allocator>
bool operator< (const charT* lhs, const basic_string<charT, traits, Allocator>& rhs) noexcept;  // constexpr since C++20

template<class charT, class traits, class Allocator>
bool operator> (const basic_string<charT, traits, Allocator>& lhs,
                const basic_string<charT, traits, Allocator>& rhs) noexcept;                    // constexpr since C++20

template<class charT, class traits, class Allocator>
bool operator> (const basic_string<charT, traits, Allocator>& lhs, const charT* rhs) noexcept;  // constexpr since C++20

template<class charT, class traits, class Allocator>
bool operator> (const charT* lhs, const basic_string<charT, traits, Allocator>& rhs) noexcept;  // constexpr since C++20

template<class charT, class traits, class Allocator>
bool operator<=(const basic_string<charT, traits, Allocator>& lhs,
                const basic_string<charT, traits, Allocator>& rhs) noexcept;                    // constexpr since C++20

template<class charT, class traits, class Allocator>
bool operator<=(const basic_string<charT, traits, Allocator>& lhs, const charT* rhs) noexcept;  // constexpr since C++20

template<class charT, class traits, class Allocator>
bool operator<=(const charT* lhs, const basic_string<charT, traits, Allocator>& rhs) noexcept;  // constexpr since C++20

template<class charT, class traits, class Allocator>
bool operator>=(const basic_string<charT, traits, Allocator>& lhs,
                const basic_string<charT, traits, Allocator>& rhs) noexcept;                    // constexpr since C++20

template<class charT, class traits, class Allocator>
bool operator>=(const basic_string<charT, traits, Allocator>& lhs, const charT* rhs) noexcept;  // constexpr since C++20

template<class charT, class traits, class Allocator>
bool operator>=(const charT* lhs, const basic_string<charT, traits, Allocator>& rhs) noexcept;  // constexpr since C++20

template<class charT, class traits, class Allocator>
void swap(basic_string<charT, traits, Allocator>& lhs,
          basic_string<charT, traits, Allocator>& rhs)
            noexcept(noexcept(lhs.swap(rhs)));                                                  // constexpr since C++20

template<class charT, class traits, class Allocator>
basic_istream<charT, traits>&
operator>>(basic_istream<charT, traits>& is, basic_string<charT, traits, Allocator>& str);

template<class charT, class traits, class Allocator>
basic_ostream<charT, traits>&
operator<<(basic_ostream<charT, traits>& os, const basic_string<charT, traits, Allocator>& str);

template<class charT, class traits, class Allocator>
basic_istream<charT, traits>&
getline(basic_istream<charT, traits>& is, basic_string<charT, traits, Allocator>& str,
        charT delim);

template<class charT, class traits, class Allocator>
basic_istream<charT, traits>&
getline(basic_istream<charT, traits>& is, basic_string<charT, traits, Allocator>& str);

template<class charT, class traits, class Allocator, class U>
typename basic_string<charT, traits, Allocator>::size_type
erase(basic_string<charT, traits, Allocator>& c, const U& value);    // C++20
template<class charT, class traits, class Allocator, class Predicate>
typename basic_string<charT, traits, Allocator>::size_type
erase_if(basic_string<charT, traits, Allocator>& c, Predicate pred); // C++20

typedef basic_string<char>    string;
typedef basic_string<wchar_t> wstring;
typedef basic_string<char8_t> u8string; // C++20
typedef basic_string<char16_t> u16string;
typedef basic_string<char32_t> u32string;

int                stoi  (const string& str, size_t* idx = nullptr, int base = 10);
long               stol  (const string& str, size_t* idx = nullptr, int base = 10);
unsigned long      stoul (const string& str, size_t* idx = nullptr, int base = 10);
long long          stoll (const string& str, size_t* idx = nullptr, int base = 10);
unsigned long long stoull(const string& str, size_t* idx = nullptr, int base = 10);

float       stof (const string& str, size_t* idx = nullptr);
double      stod (const string& str, size_t* idx = nullptr);
long double stold(const string& str, size_t* idx = nullptr);

string to_string(int val);
string to_string(unsigned val);
string to_string(long val);
string to_string(unsigned long val);
string to_string(long long val);
string to_string(unsigned long long val);
string to_string(float val);
string to_string(double val);
string to_string(long double val);

int                stoi  (const wstring& str, size_t* idx = nullptr, int base = 10);
long               stol  (const wstring& str, size_t* idx = nullptr, int base = 10);
unsigned long      stoul (const wstring& str, size_t* idx = nullptr, int base = 10);
long long          stoll (const wstring& str, size_t* idx = nullptr, int base = 10);
unsigned long long stoull(const wstring& str, size_t* idx = nullptr, int base = 10);

float       stof (const wstring& str, size_t* idx = nullptr);
double      stod (const wstring& str, size_t* idx = nullptr);
long double stold(const wstring& str, size_t* idx = nullptr);

wstring to_wstring(int val);
wstring to_wstring(unsigned val);
wstring to_wstring(long val);
wstring to_wstring(unsigned long val);
wstring to_wstring(long long val);
wstring to_wstring(unsigned long long val);
wstring to_wstring(float val);
wstring to_wstring(double val);
wstring to_wstring(long double val);

template <> struct hash<string>;
template <> struct hash<u8string>; // C++20
template <> struct hash<u16string>;
template <> struct hash<u32string>;
template <> struct hash<wstring>;

basic_string<char>     operator "" s( const char *str,     size_t len );           // C++14, constexpr since C++20
basic_string<wchar_t>  operator "" s( const wchar_t *str,  size_t len );           // C++14, constexpr since C++20
constexpr basic_string<char8_t>  operator "" s( const char8_t *str,  size_t len ); // C++20
basic_string<char16_t> operator "" s( const char16_t *str, size_t len );           // C++14, constexpr since C++20
basic_string<char32_t> operator "" s( const char32_t *str, size_t len );           // C++14, constexpr since C++20

}  // std

*/

#include <__algorithm/max.h>
#include <__algorithm/min.h>
#include <__algorithm/remove.h>
#include <__algorithm/remove_if.h>
#include <__assert> // all public C++ headers provide the assertion handler
#include <__config>
#include <__debug>
#include <__format/enable_insertable.h>
#include <__functional/hash.h>
#include <__functional/unary_function.h>
#include <__ios/fpos.h>
#include <__iterator/distance.h>
#include <__iterator/iterator_traits.h>
#include <__iterator/reverse_iterator.h>
#include <__iterator/wrap_iter.h>
#include <__memory/allocate_at_least.h>
#include <__memory/swap_allocator.h>
#include <__string/char_traits.h>
#include <__string/extern_template_lists.h>
#include <__utility/auto_cast.h>
#include <__utility/move.h>
#include <__utility/swap.h>
#include <__utility/unreachable.h>
#include <climits>
#include <cstdint>
#include <cstdio>  // EOF
#include <cstdlib>
#include <cstring>
#include <iosfwd>
#include <limits>
#include <memory>
#include <stdexcept>
#include <string_view>
#include <type_traits>
#include <version>

#ifndef _LIBCPP_HAS_NO_WIDE_CHARACTERS
#  include <cwchar>
#endif

#ifndef _LIBCPP_REMOVE_TRANSITIVE_INCLUDES
#  include <algorithm>
#  include <functional>
#  include <iterator>
#  include <new>
#  include <typeinfo>
#  include <utility>
#  include <vector>
#endif

// standard-mandated includes

// [iterator.range]
#include <__iterator/access.h>
#include <__iterator/data.h>
#include <__iterator/empty.h>
#include <__iterator/reverse_access.h>
#include <__iterator/size.h>

// [string.syn]
#include <compare>
#include <initializer_list>

#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
#  pragma GCC system_header
#endif

_LIBCPP_PUSH_MACROS
#include <__undef_macros>


_LIBCPP_BEGIN_NAMESPACE_STD

// basic_string

template<class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>
_LIBCPP_CONSTEXPR_AFTER_CXX17
operator+(const basic_string<_CharT, _Traits, _Allocator>& __x,
          const basic_string<_CharT, _Traits, _Allocator>& __y);

template<class _CharT, class _Traits, class _Allocator>
_LIBCPP_CONSTEXPR_AFTER_CXX17
basic_string<_CharT, _Traits, _Allocator>
operator+(const _CharT* __x, const basic_string<_CharT,_Traits,_Allocator>& __y);

template<class _CharT, class _Traits, class _Allocator>
_LIBCPP_CONSTEXPR_AFTER_CXX17
basic_string<_CharT, _Traits, _Allocator>
operator+(_CharT __x, const basic_string<_CharT,_Traits,_Allocator>& __y);

template<class _CharT, class _Traits, class _Allocator>
inline _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_AFTER_CXX17
basic_string<_CharT, _Traits, _Allocator>
operator+(const basic_string<_CharT, _Traits, _Allocator>& __x, const _CharT* __y);

template<class _CharT, class _Traits, class _Allocator>
_LIBCPP_CONSTEXPR_AFTER_CXX17
basic_string<_CharT, _Traits, _Allocator>
operator+(const basic_string<_CharT, _Traits, _Allocator>& __x, _CharT __y);

extern template _LIBCPP_FUNC_VIS string operator+<char, char_traits<char>, allocator<char> >(char const*, string const&);

template <class _Iter>
struct __string_is_trivial_iterator : public false_type {};

template <class _Tp>
struct __string_is_trivial_iterator<_Tp*>
    : public is_arithmetic<_Tp> {};

template <class _Iter>
struct __string_is_trivial_iterator<__wrap_iter<_Iter> >
    : public __string_is_trivial_iterator<_Iter> {};

template <class _CharT, class _Traits, class _Tp>
struct __can_be_converted_to_string_view : public _BoolConstant<
      is_convertible<const _Tp&, basic_string_view<_CharT, _Traits> >::value &&
     !is_convertible<const _Tp&, const _CharT*>::value
    > {};

#ifndef _LIBCPP_HAS_NO_CHAR8_T
typedef basic_string<char8_t> u8string;
#endif
typedef basic_string<char16_t> u16string;
typedef basic_string<char32_t> u32string;

struct __uninitialized_size_tag {};

template<class _CharT, class _Traits, class _Allocator>
class
    _LIBCPP_TEMPLATE_VIS
#ifndef _LIBCPP_HAS_NO_CHAR8_T
    _LIBCPP_PREFERRED_NAME(u8string)
#endif
    _LIBCPP_PREFERRED_NAME(u16string)
    _LIBCPP_PREFERRED_NAME(u32string)
    basic_string
{
public:
    typedef basic_string                                 __self;
    typedef basic_string_view<_CharT, _Traits>           __self_view;
    typedef _Traits                                      traits_type;
    typedef _CharT                                       value_type;
    typedef _Allocator                                   allocator_type;
    typedef allocator_traits<allocator_type>             __alloc_traits;
    typedef typename __alloc_traits::size_type           size_type;
    typedef typename __alloc_traits::difference_type     difference_type;
    typedef value_type&                                  reference;
    typedef const value_type&                            const_reference;
    typedef typename __alloc_traits::pointer             pointer;
    typedef typename __alloc_traits::const_pointer       const_pointer;

    static_assert((!is_array<value_type>::value), "Character type of basic_string must not be an array");
    static_assert(( is_standard_layout<value_type>::value), "Character type of basic_string must be standard-layout");
    static_assert(( is_trivial<value_type>::value), "Character type of basic_string must be trivial");
    static_assert(( is_same<_CharT, typename traits_type::char_type>::value),
                  "traits_type::char_type must be the same type as CharT");
    static_assert(( is_same<typename allocator_type::value_type, value_type>::value),
                  "Allocator::value_type must be same type as value_type");

    typedef __wrap_iter<pointer>                         iterator;
    typedef __wrap_iter<const_pointer>                   const_iterator;
    typedef std::reverse_iterator<iterator>              reverse_iterator;
    typedef std::reverse_iterator<const_iterator>        const_reverse_iterator;

private:
    static_assert(CHAR_BIT == 8, "This implementation assumes that one byte contains 8 bits");

#ifdef _LIBCPP_ABI_ALTERNATE_STRING_LAYOUT

    struct __long
    {
        pointer   __data_;
        size_type __size_;
        size_type __cap_ : sizeof(size_type) * CHAR_BIT - 1;
        size_type __is_long_ : 1;
    };

    enum {__min_cap = (sizeof(__long) - 1)/sizeof(value_type) > 2 ?
                      (sizeof(__long) - 1)/sizeof(value_type) : 2};

    struct __short
    {
        value_type __data_[__min_cap];
        unsigned char __padding_[sizeof(value_type) - 1];
        unsigned char __size_ : 7;
        unsigned char __is_long_ : 1;
    };

// The __endian_factor is required because the field we use to store the size
// has one fewer bit than it would if it were not a bitfield.
//
// If the LSB is used to store the short-flag in the short string representation,
// we have to multiply the size by two when it is stored and divide it by two when
// it is loaded to make sure that we always store an even number. In the long string
// representation, we can ignore this because we can assume that we always allocate
// an even amount of value_types.
//
// If the MSB is used for the short-flag, the max_size() is numeric_limits<size_type>::max() / 2.
// This does not impact the short string representation, since we never need the MSB
// for representing the size of a short string anyway.

#ifdef _LIBCPP_BIG_ENDIAN
    static const size_type __endian_factor = 2;
#else
    static const size_type __endian_factor = 1;
#endif

#else // _LIBCPP_ABI_ALTERNATE_STRING_LAYOUT

#ifdef _LIBCPP_BIG_ENDIAN
    static const size_type __endian_factor = 1;
#else
    static const size_type __endian_factor = 2;
#endif

    // Attribute 'packed' is used to keep the layout compatible with the
    // previous definition that did not use bit fields. This is because on
    // some platforms bit fields have a default size rather than the actual
    // size used, e.g., it is 4 bytes on AIX. See D128285 for details.
    struct __long
    {
        struct _LIBCPP_PACKED {
            size_type __is_long_ : 1;
            size_type __cap_ : sizeof(size_type) * CHAR_BIT - 1;
        };
        size_type __size_;
        pointer   __data_;
    };

    enum {__min_cap = (sizeof(__long) - 1)/sizeof(value_type) > 2 ?
                      (sizeof(__long) - 1)/sizeof(value_type) : 2};

    struct __short
    {
        struct _LIBCPP_PACKED {
            unsigned char __is_long_ : 1;
            unsigned char __size_ : 7;
        };
        char __padding_[sizeof(value_type) - 1];
        value_type __data_[__min_cap];
    };

#endif // _LIBCPP_ABI_ALTERNATE_STRING_LAYOUT

    static_assert(sizeof(__short) == (sizeof(value_type) * (__min_cap + 1)), "__short has an unexpected size.");

    union __ulx{__long __lx; __short __lxx;};

    enum {__n_words = sizeof(__ulx) / sizeof(size_type)};

    struct __raw
    {
        size_type __words[__n_words];
    };

    struct __rep
    {
        union
        {
            __long  __l;
            __short __s;
            __raw   __r;
        };
    };

    __compressed_pair<__rep, allocator_type> __r_;

    // Construct a string with the given allocator and enough storage to hold `__size` characters, but
    // don't initialize the characters. The contents of the string, including the null terminator, must be
    // initialized separately.
    _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_AFTER_CXX17
    explicit basic_string(__uninitialized_size_tag, size_type __size, const allocator_type& __a)
            : __r_(__default_init_tag(), __a) {
        if (__size > max_size())
            __throw_length_error();
        if (__fits_in_sso(__size)) {
            __zero();
            __set_short_size(__size);
        } else {
            auto __capacity = __recommend(__size) + 1;
            auto __allocation = __alloc_traits::allocate(__alloc(), __capacity);
            __begin_lifetime(__allocation, __capacity);
            __set_long_cap(__capacity);
            __set_long_pointer(__allocation);
            __set_long_size(__size);
        }
        std::__debug_db_insert_c(this);
    }

public:
    _LIBCPP_TEMPLATE_DATA_VIS
    static const size_type npos = -1;

    _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_AFTER_CXX17 basic_string()
        _NOEXCEPT_(is_nothrow_default_constructible<allocator_type>::value);

    _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_AFTER_CXX17 explicit basic_string(const allocator_type& __a)
#if _LIBCPP_STD_VER <= 14
        _NOEXCEPT_(is_nothrow_copy_constructible<allocator_type>::value);
#else
        _NOEXCEPT;
#endif

    _LIBCPP_CONSTEXPR_AFTER_CXX17 basic_string(const basic_string& __str);
    _LIBCPP_CONSTEXPR_AFTER_CXX17 basic_string(const basic_string& __str, const allocator_type& __a);

#ifndef _LIBCPP_CXX03_LANG
    _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_AFTER_CXX17
    basic_string(basic_string&& __str)
#if _LIBCPP_STD_VER <= 14
        _NOEXCEPT_(is_nothrow_move_constructible<allocator_type>::value);
#else
        _NOEXCEPT;
#endif

    _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_AFTER_CXX17
    basic_string(basic_string&& __str, const allocator_type& __a);
#endif // _LIBCPP_CXX03_LANG

    template <class = __enable_if_t<__is_allocator<_Allocator>::value, nullptr_t> >
    _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_AFTER_CXX17
    basic_string(const _CharT* __s) : __r_(__default_init_tag(), __default_init_tag()) {
      _LIBCPP_ASSERT(__s != nullptr, "basic_string(const char*) detected nullptr");
      __init(__s, traits_type::length(__s));
      std::__debug_db_insert_c(this);
    }

    template <class = __enable_if_t<__is_allocator<_Allocator>::value, nullptr_t> >
        _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_AFTER_CXX17
        basic_string(const _CharT* __s, const _Allocator& __a);

#if _LIBCPP_STD_VER > 20
    basic_string(nullptr_t) = delete;
#endif

    _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_AFTER_CXX17
    basic_string(const _CharT* __s, size_type __n);
    _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_AFTER_CXX17
    basic_string(const _CharT* __s, size_type __n, const _Allocator& __a);
    _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_AFTER_CXX17
    basic_string(size_type __n, _CharT __c);

    template <class = __enable_if_t<__is_allocator<_Allocator>::value, nullptr_t> >
        _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_AFTER_CXX17
        basic_string(size_type __n, _CharT __c, const _Allocator& __a);

    _LIBCPP_CONSTEXPR_AFTER_CXX17
    basic_string(const basic_string& __str, size_type __pos, size_type __n,
                 const _Allocator& __a = _Allocator());
    _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_AFTER_CXX17
    basic_string(const basic_string& __str, size_type __pos,
                 const _Allocator& __a = _Allocator());

    template<class _Tp, class = __enable_if_t<__can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value && !__is_same_uncvref<_Tp, basic_string>::value> >
        _LIBCPP_METHOD_TEMPLATE_IMPLICIT_INSTANTIATION_VIS _LIBCPP_CONSTEXPR_AFTER_CXX17
        basic_string(const _Tp& __t, size_type __pos, size_type __n,
                     const allocator_type& __a = allocator_type());

    template<class _Tp, class = __enable_if_t<__can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value &&
                                          !__is_same_uncvref<_Tp, basic_string>::value> >
        _LIBCPP_METHOD_TEMPLATE_IMPLICIT_INSTANTIATION_VIS _LIBCPP_CONSTEXPR_AFTER_CXX17
        explicit basic_string(const _Tp& __t);

    template<class _Tp, class = __enable_if_t<__can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value && !__is_same_uncvref<_Tp, basic_string>::value> >
        _LIBCPP_METHOD_TEMPLATE_IMPLICIT_INSTANTIATION_VIS _LIBCPP_CONSTEXPR_AFTER_CXX17
        explicit basic_string(const _Tp& __t, const allocator_type& __a);

    template<class _InputIterator, class = __enable_if_t<__is_cpp17_input_iterator<_InputIterator>::value> >
        _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_AFTER_CXX17
        basic_string(_InputIterator __first, _InputIterator __last);
    template<class _InputIterator, class = __enable_if_t<__is_cpp17_input_iterator<_InputIterator>::value> >
        _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_AFTER_CXX17
        basic_string(_InputIterator __first, _InputIterator __last, const allocator_type& __a);
#ifndef _LIBCPP_CXX03_LANG
    _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_AFTER_CXX17
    basic_string(initializer_list<_CharT> __il);
    _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_AFTER_CXX17
    basic_string(initializer_list<_CharT> __il, const _Allocator& __a);
#endif // _LIBCPP_CXX03_LANG

    inline _LIBCPP_CONSTEXPR_AFTER_CXX17 ~basic_string();

    _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_AFTER_CXX17
    operator __self_view() const _NOEXCEPT { return __self_view(data(), size()); }

    _LIBCPP_CONSTEXPR_AFTER_CXX17 basic_string& operator=(const basic_string& __str);

    template <class _Tp, class = __enable_if_t<__can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value &&
                                               !__is_same_uncvref<_Tp, basic_string>::value> >
    _LIBCPP_CONSTEXPR_AFTER_CXX17 basic_string& operator=(const _Tp& __t) {
      __self_view __sv = __t;
      return assign(__sv);
    }

#ifndef _LIBCPP_CXX03_LANG
    _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_AFTER_CXX17
    basic_string& operator=(basic_string&& __str)
        _NOEXCEPT_((__noexcept_move_assign_container<_Allocator, __alloc_traits>::value));
     _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_AFTER_CXX17
    basic_string& operator=(initializer_list<value_type> __il) {return assign(__il.begin(), __il.size());}
#endif
    _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_AFTER_CXX17
    basic_string& operator=(const value_type* __s) {return assign(__s);}
#if _LIBCPP_STD_VER > 20
    basic_string& operator=(nullptr_t) = delete;
#endif
    _LIBCPP_CONSTEXPR_AFTER_CXX17 basic_string& operator=(value_type __c);

    _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_AFTER_CXX17
    iterator begin() _NOEXCEPT
        {return iterator(this, __get_pointer());}
    _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_AFTER_CXX17
    const_iterator begin() const _NOEXCEPT
        {return const_iterator(this, __get_pointer());}
    _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_AFTER_CXX17
    iterator end() _NOEXCEPT
        {return iterator(this, __get_pointer() + size());}
    _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_AFTER_CXX17
    const_iterator end() const _NOEXCEPT
        {return const_iterator(this, __get_pointer() + size());}

    _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_AFTER_CXX17
    reverse_iterator rbegin() _NOEXCEPT
        {return reverse_iterator(end());}
    _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_AFTER_CXX17
    const_reverse_iterator rbegin() const _NOEXCEPT
        {return const_reverse_iterator(end());}
    _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_AFTER_CXX17
    reverse_iterator rend() _NOEXCEPT
        {return reverse_iterator(begin());}
    _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_AFTER_CXX17
    const_reverse_iterator rend() const _NOEXCEPT
        {return const_reverse_iterator(begin());}

    _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_AFTER_CXX17
    const_iterator cbegin() const _NOEXCEPT
        {return begin();}
    _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_AFTER_CXX17
    const_iterator cend() const _NOEXCEPT
        {return end();}
    _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_AFTER_CXX17
    const_reverse_iterator crbegin() const _NOEXCEPT
        {return rbegin();}
    _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_AFTER_CXX17
    const_reverse_iterator crend() const _NOEXCEPT
        {return rend();}

    _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_AFTER_CXX17 size_type size() const _NOEXCEPT
        {return __is_long() ? __get_long_size() : __get_short_size();}
    _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_AFTER_CXX17 size_type length() const _NOEXCEPT {return size();}
    _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_AFTER_CXX17 size_type max_size() const _NOEXCEPT;
    _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_AFTER_CXX17 size_type capacity() const _NOEXCEPT {
        return (__is_long() ? __get_long_cap() : static_cast<size_type>(__min_cap)) - 1;
    }

    _LIBCPP_CONSTEXPR_AFTER_CXX17 void resize(size_type __n, value_type __c);
    _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_AFTER_CXX17 void resize(size_type __n) { resize(__n, value_type()); }

    _LIBCPP_CONSTEXPR_AFTER_CXX17 void reserve(size_type __requested_capacity);

#if _LIBCPP_STD_VER > 20
    template <class _Op>
    _LIBCPP_HIDE_FROM_ABI constexpr
    void resize_and_overwrite(size_type __n, _Op __op) {
      __resize_default_init(__n);
      __erase_to_end(std::move(__op)(data(), _LIBCPP_AUTO_CAST(__n)));
    }
#endif

    _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_AFTER_CXX17 void __resize_default_init(size_type __n);

    _LIBCPP_DEPRECATED_IN_CXX20 _LIBCPP_HIDE_FROM_ABI void reserve() _NOEXCEPT { shrink_to_fit(); }
    _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_AFTER_CXX17 void shrink_to_fit() _NOEXCEPT;
    _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_AFTER_CXX17 void clear() _NOEXCEPT;

    _LIBCPP_NODISCARD_AFTER_CXX17 _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_AFTER_CXX17
    bool empty() const _NOEXCEPT {return size() == 0;}

    _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_AFTER_CXX17
    const_reference operator[](size_type __pos) const _NOEXCEPT;
    _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_AFTER_CXX17 reference operator[](size_type __pos) _NOEXCEPT;

    _LIBCPP_CONSTEXPR_AFTER_CXX17 const_reference at(size_type __n) const;
    _LIBCPP_CONSTEXPR_AFTER_CXX17 reference       at(size_type __n);

    _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_AFTER_CXX17 basic_string& operator+=(const basic_string& __str) {
        return append(__str);
    }

    template <class _Tp>
    _LIBCPP_METHOD_TEMPLATE_IMPLICIT_INSTANTIATION_VIS _LIBCPP_CONSTEXPR_AFTER_CXX17
    __enable_if_t
        <
            __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value
            && !__is_same_uncvref<_Tp, basic_string >::value,
            basic_string&
        >
    operator+=(const _Tp& __t) {
        __self_view __sv = __t; return append(__sv);
    }

    _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_AFTER_CXX17 basic_string& operator+=(const value_type* __s) {
        return append(__s);
    }

    _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_AFTER_CXX17 basic_string& operator+=(value_type __c) {
        push_back(__c);
        return *this;
    }

#ifndef _LIBCPP_CXX03_LANG
    _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_AFTER_CXX17
    basic_string& operator+=(initializer_list<value_type> __il) { return append(__il); }
#endif // _LIBCPP_CXX03_LANG

    _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_AFTER_CXX17
    basic_string& append(const basic_string& __str);

    template <class _Tp>
    _LIBCPP_METHOD_TEMPLATE_IMPLICIT_INSTANTIATION_VIS _LIBCPP_CONSTEXPR_AFTER_CXX17
    __enable_if_t<
            __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value
            && !__is_same_uncvref<_Tp, basic_string>::value,
            basic_string&
        >
                  append(const _Tp& __t) { __self_view __sv = __t; return append(__sv.data(), __sv.size()); }
    _LIBCPP_CONSTEXPR_AFTER_CXX17 basic_string& append(const basic_string& __str, size_type __pos, size_type __n=npos);

    template <class _Tp>
    _LIBCPP_METHOD_TEMPLATE_IMPLICIT_INSTANTIATION_VIS _LIBCPP_CONSTEXPR_AFTER_CXX17
    __enable_if_t
        <
            __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value
            && !__is_same_uncvref<_Tp, basic_string>::value,
            basic_string&
        >
                  append(const _Tp& __t, size_type __pos, size_type __n=npos);
    _LIBCPP_CONSTEXPR_AFTER_CXX17 basic_string& append(const value_type* __s, size_type __n);
    _LIBCPP_CONSTEXPR_AFTER_CXX17 basic_string& append(const value_type* __s);
    _LIBCPP_CONSTEXPR_AFTER_CXX17 basic_string& append(size_type __n, value_type __c);

    _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_AFTER_CXX17
    void __append_default_init(size_type __n);

    template<class _InputIterator>
    _LIBCPP_METHOD_TEMPLATE_IMPLICIT_INSTANTIATION_VIS
    __enable_if_t
        <
            __is_exactly_cpp17_input_iterator<_InputIterator>::value,
            basic_string&
        >
    _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_AFTER_CXX17
    append(_InputIterator __first, _InputIterator __last) {
      const basic_string __temp(__first, __last, __alloc());
      append(__temp.data(), __temp.size());
      return *this;
    }
    template<class _ForwardIterator>
    _LIBCPP_METHOD_TEMPLATE_IMPLICIT_INSTANTIATION_VIS
    __enable_if_t
        <
            __is_cpp17_forward_iterator<_ForwardIterator>::value,
            basic_string&
        >
    _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_AFTER_CXX17
    append(_ForwardIterator __first, _ForwardIterator __last);

#ifndef _LIBCPP_CXX03_LANG
    _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_AFTER_CXX17
    basic_string& append(initializer_list<value_type> __il) {return append(__il.begin(), __il.size());}
#endif // _LIBCPP_CXX03_LANG

    _LIBCPP_CONSTEXPR_AFTER_CXX17 void push_back(value_type __c);
    _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_AFTER_CXX17 void pop_back();
    _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_AFTER_CXX17 reference       front() _NOEXCEPT;
    _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_AFTER_CXX17 const_reference front() const _NOEXCEPT;
    _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_AFTER_CXX17 reference       back() _NOEXCEPT;
    _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_AFTER_CXX17 const_reference back() const _NOEXCEPT;

    template <class _Tp>
    _LIBCPP_METHOD_TEMPLATE_IMPLICIT_INSTANTIATION_VIS _LIBCPP_CONSTEXPR_AFTER_CXX17
    __enable_if_t
        <
            __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,
            basic_string&
        >
                 assign(const _Tp & __t) { __self_view __sv = __t; return assign(__sv.data(), __sv.size()); }
    _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_AFTER_CXX17
    basic_string& assign(const basic_string& __str) { return *this = __str; }
#ifndef _LIBCPP_CXX03_LANG
    _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_AFTER_CXX17
    basic_string& assign(basic_string&& __str)
        _NOEXCEPT_((__noexcept_move_assign_container<_Allocator, __alloc_traits>::value))
        {*this = std::move(__str); return *this;}
#endif
    _LIBCPP_CONSTEXPR_AFTER_CXX17 basic_string& assign(const basic_string& __str, size_type __pos, size_type __n=npos);
    template <class _Tp>
    _LIBCPP_METHOD_TEMPLATE_IMPLICIT_INSTANTIATION_VIS _LIBCPP_CONSTEXPR_AFTER_CXX17
    __enable_if_t
        <
            __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value
            && !__is_same_uncvref<_Tp, basic_string>::value,
            basic_string&
        >
                  assign(const _Tp & __t, size_type __pos, size_type __n=npos);
    _LIBCPP_CONSTEXPR_AFTER_CXX17 basic_string& assign(const value_type* __s, size_type __n);
    _LIBCPP_CONSTEXPR_AFTER_CXX17 basic_string& assign(const value_type* __s);
    _LIBCPP_CONSTEXPR_AFTER_CXX17 basic_string& assign(size_type __n, value_type __c);
    template<class _InputIterator>
    _LIBCPP_METHOD_TEMPLATE_IMPLICIT_INSTANTIATION_VIS _LIBCPP_CONSTEXPR_AFTER_CXX17
    __enable_if_t
        <
            __is_exactly_cpp17_input_iterator<_InputIterator>::value,
            basic_string&
        >
        assign(_InputIterator __first, _InputIterator __last);
    template<class _ForwardIterator>
    _LIBCPP_METHOD_TEMPLATE_IMPLICIT_INSTANTIATION_VIS _LIBCPP_CONSTEXPR_AFTER_CXX17
    __enable_if_t
        <
            __is_cpp17_forward_iterator<_ForwardIterator>::value,
            basic_string&
        >
        assign(_ForwardIterator __first, _ForwardIterator __last);
#ifndef _LIBCPP_CXX03_LANG
    _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_AFTER_CXX17
    basic_string& assign(initializer_list<value_type> __il) {return assign(__il.begin(), __il.size());}
#endif // _LIBCPP_CXX03_LANG

    _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_AFTER_CXX17
    basic_string& insert(size_type __pos1, const basic_string& __str);

    template <class _Tp>
    _LIBCPP_METHOD_TEMPLATE_IMPLICIT_INSTANTIATION_VIS _LIBCPP_CONSTEXPR_AFTER_CXX17
    __enable_if_t
        <
            __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,
            basic_string&
        >
                 insert(size_type __pos1, const _Tp& __t)
    { __self_view __sv = __t; return insert(__pos1, __sv.data(), __sv.size()); }

    template <class _Tp>
    _LIBCPP_METHOD_TEMPLATE_IMPLICIT_INSTANTIATION_VIS _LIBCPP_CONSTEXPR_AFTER_CXX17
    __enable_if_t
        <
            __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value && !__is_same_uncvref<_Tp, basic_string>::value,
            basic_string&
        >
                  insert(size_type __pos1, const _Tp& __t, size_type __pos2, size_type __n=npos);
    _LIBCPP_CONSTEXPR_AFTER_CXX17
    basic_string& insert(size_type __pos1, const basic_string& __str, size_type __pos2, size_type __n=npos);
    _LIBCPP_CONSTEXPR_AFTER_CXX17 basic_string& insert(size_type __pos, const value_type* __s, size_type __n);
    _LIBCPP_CONSTEXPR_AFTER_CXX17 basic_string& insert(size_type __pos, const value_type* __s);
    _LIBCPP_CONSTEXPR_AFTER_CXX17 basic_string& insert(size_type __pos, size_type __n, value_type __c);
    _LIBCPP_CONSTEXPR_AFTER_CXX17 iterator      insert(const_iterator __pos, value_type __c);
    _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_AFTER_CXX17
    iterator      insert(const_iterator __pos, size_type __n, value_type __c);
    template<class _InputIterator>
    _LIBCPP_METHOD_TEMPLATE_IMPLICIT_INSTANTIATION_VIS _LIBCPP_CONSTEXPR_AFTER_CXX17
    __enable_if_t
        <
            __is_exactly_cpp17_input_iterator<_InputIterator>::value,
            iterator
        >
        insert(const_iterator __pos, _InputIterator __first, _InputIterator __last);
    template<class _ForwardIterator>
    _LIBCPP_METHOD_TEMPLATE_IMPLICIT_INSTANTIATION_VIS _LIBCPP_CONSTEXPR_AFTER_CXX17
    __enable_if_t
        <
            __is_cpp17_forward_iterator<_ForwardIterator>::value,
            iterator
        >
        insert(const_iterator __pos, _ForwardIterator __first, _ForwardIterator __last);
#ifndef _LIBCPP_CXX03_LANG
    _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_AFTER_CXX17
    iterator insert(const_iterator __pos, initializer_list<value_type> __il)
                    {return insert(__pos, __il.begin(), __il.end());}
#endif // _LIBCPP_CXX03_LANG

    _LIBCPP_CONSTEXPR_AFTER_CXX17 basic_string& erase(size_type __pos = 0, size_type __n = npos);
    _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_AFTER_CXX17
    iterator      erase(const_iterator __pos);
    _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_AFTER_CXX17
    iterator      erase(const_iterator __first, const_iterator __last);

    _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_AFTER_CXX17
    basic_string& replace(size_type __pos1, size_type __n1, const basic_string& __str);

    template <class _Tp>
    _LIBCPP_METHOD_TEMPLATE_IMPLICIT_INSTANTIATION_VIS _LIBCPP_CONSTEXPR_AFTER_CXX17
    __enable_if_t
        <
            __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,
            basic_string&
        >
                  replace(size_type __pos1, size_type __n1, const _Tp& __t) { __self_view __sv = __t; return replace(__pos1, __n1, __sv.data(), __sv.size()); }
    _LIBCPP_CONSTEXPR_AFTER_CXX17
    basic_string& replace(size_type __pos1, size_type __n1, const basic_string& __str, size_type __pos2, size_type __n2=npos);
    template <class _Tp>
    _LIBCPP_METHOD_TEMPLATE_IMPLICIT_INSTANTIATION_VIS _LIBCPP_CONSTEXPR_AFTER_CXX17
    __enable_if_t
        <
            __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value  && !__is_same_uncvref<_Tp, basic_string>::value,
            basic_string&
        >
                  replace(size_type __pos1, size_type __n1, const _Tp& __t, size_type __pos2, size_type __n2=npos);
    _LIBCPP_CONSTEXPR_AFTER_CXX17
    basic_string& replace(size_type __pos, size_type __n1, const value_type* __s, size_type __n2);
    _LIBCPP_CONSTEXPR_AFTER_CXX17 basic_string& replace(size_type __pos, size_type __n1, const value_type* __s);
    _LIBCPP_CONSTEXPR_AFTER_CXX17 basic_string& replace(size_type __pos, size_type __n1, size_type __n2, value_type __c);
    _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_AFTER_CXX17
    basic_string& replace(const_iterator __i1, const_iterator __i2, const basic_string& __str);

    template <class _Tp>
    _LIBCPP_METHOD_TEMPLATE_IMPLICIT_INSTANTIATION_VIS _LIBCPP_CONSTEXPR_AFTER_CXX17
    __enable_if_t
        <
            __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,
            basic_string&
        >
                  replace(const_iterator __i1, const_iterator __i2, const _Tp& __t) { __self_view __sv = __t; return replace(__i1 - begin(), __i2 - __i1, __sv); }

    _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_AFTER_CXX17
    basic_string& replace(const_iterator __i1, const_iterator __i2, const value_type* __s, size_type __n);
    _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_AFTER_CXX17
    basic_string& replace(const_iterator __i1, const_iterator __i2, const value_type* __s);
    _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_AFTER_CXX17
    basic_string& replace(const_iterator __i1, const_iterator __i2, size_type __n, value_type __c);
    template<class _InputIterator>
    _LIBCPP_METHOD_TEMPLATE_IMPLICIT_INSTANTIATION_VIS _LIBCPP_CONSTEXPR_AFTER_CXX17
    __enable_if_t
        <
            __is_cpp17_input_iterator<_InputIterator>::value,
            basic_string&
        >
        replace(const_iterator __i1, const_iterator __i2, _InputIterator __j1, _InputIterator __j2);
#ifndef _LIBCPP_CXX03_LANG
    _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_AFTER_CXX17
    basic_string& replace(const_iterator __i1, const_iterator __i2, initializer_list<value_type> __il)
        {return replace(__i1, __i2, __il.begin(), __il.end());}
#endif // _LIBCPP_CXX03_LANG

    _LIBCPP_CONSTEXPR_AFTER_CXX17 size_type copy(value_type* __s, size_type __n, size_type __pos = 0) const;
    _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_AFTER_CXX17
    basic_string substr(size_type __pos = 0, size_type __n = npos) const;

    _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_AFTER_CXX17
    void swap(basic_string& __str)
#if _LIBCPP_STD_VER >= 14
        _NOEXCEPT;
#else
        _NOEXCEPT_(!__alloc_traits::propagate_on_container_swap::value ||
                    __is_nothrow_swappable<allocator_type>::value);
#endif

    _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_AFTER_CXX17
    const value_type* c_str() const _NOEXCEPT {return data();}
    _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_AFTER_CXX17
    const value_type* data() const _NOEXCEPT  {return std::__to_address(__get_pointer());}
#if _LIBCPP_STD_VER > 14 || defined(_LIBCPP_BUILDING_LIBRARY)
    _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_AFTER_CXX17
    value_type* data()             _NOEXCEPT  {return std::__to_address(__get_pointer());}
#endif

    _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_AFTER_CXX17
    allocator_type get_allocator() const _NOEXCEPT {return __alloc();}

    _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_AFTER_CXX17
    size_type find(const basic_string& __str, size_type __pos = 0) const _NOEXCEPT;

    template <class _Tp>
    _LIBCPP_METHOD_TEMPLATE_IMPLICIT_INSTANTIATION_VIS _LIBCPP_CONSTEXPR_AFTER_CXX17
    __enable_if_t
        <
            __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,
            size_type
        >
              find(const _Tp& __t, size_type __pos = 0) const _NOEXCEPT;
    _LIBCPP_CONSTEXPR_AFTER_CXX17
    size_type find(const value_type* __s, size_type __pos, size_type __n) const _NOEXCEPT;
    _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_AFTER_CXX17
    size_type find(const value_type* __s, size_type __pos = 0) const _NOEXCEPT;
    _LIBCPP_CONSTEXPR_AFTER_CXX17 size_type find(value_type __c, size_type __pos = 0) const _NOEXCEPT;

    _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_AFTER_CXX17
    size_type rfind(const basic_string& __str, size_type __pos = npos) const _NOEXCEPT;

    template <class _Tp>
    _LIBCPP_METHOD_TEMPLATE_IMPLICIT_INSTANTIATION_VIS _LIBCPP_CONSTEXPR_AFTER_CXX17
    __enable_if_t
        <
            __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,
            size_type
        >
              rfind(const _Tp& __t, size_type __pos = npos) const _NOEXCEPT;
    _LIBCPP_CONSTEXPR_AFTER_CXX17
    size_type rfind(const value_type* __s, size_type __pos, size_type __n) const _NOEXCEPT;
    _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_AFTER_CXX17
    size_type rfind(const value_type* __s, size_type __pos = npos) const _NOEXCEPT;
    _LIBCPP_CONSTEXPR_AFTER_CXX17 size_type rfind(value_type __c, size_type __pos = npos) const _NOEXCEPT;

    _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_AFTER_CXX17
    size_type find_first_of(const basic_string& __str, size_type __pos = 0) const _NOEXCEPT;

    template <class _Tp>
    _LIBCPP_METHOD_TEMPLATE_IMPLICIT_INSTANTIATION_VIS _LIBCPP_CONSTEXPR_AFTER_CXX17
    __enable_if_t
        <
            __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,
            size_type
        >
              find_first_of(const _Tp& __t, size_type __pos = 0) const _NOEXCEPT;
    _LIBCPP_CONSTEXPR_AFTER_CXX17
    size_type find_first_of(const value_type* __s, size_type __pos, size_type __n) const _NOEXCEPT;
    _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_AFTER_CXX17
    size_type find_first_of(const value_type* __s, size_type __pos = 0) const _NOEXCEPT;
    _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_AFTER_CXX17
    size_type find_first_of(value_type __c, size_type __pos = 0) const _NOEXCEPT;

    _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_AFTER_CXX17
    size_type find_last_of(const basic_string& __str, size_type __pos = npos) const _NOEXCEPT;

    template <class _Tp>
    _LIBCPP_METHOD_TEMPLATE_IMPLICIT_INSTANTIATION_VIS _LIBCPP_CONSTEXPR_AFTER_CXX17
    __enable_if_t
        <
            __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,
            size_type
        >
              find_last_of(const _Tp& __t, size_type __pos = npos) const _NOEXCEPT;
    _LIBCPP_CONSTEXPR_AFTER_CXX17
    size_type find_last_of(const value_type* __s, size_type __pos, size_type __n) const _NOEXCEPT;
    _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_AFTER_CXX17
    size_type find_last_of(const value_type* __s, size_type __pos = npos) const _NOEXCEPT;
    _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_AFTER_CXX17
    size_type find_last_of(value_type __c, size_type __pos = npos) const _NOEXCEPT;

    _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_AFTER_CXX17
    size_type find_first_not_of(const basic_string& __str, size_type __pos = 0) const _NOEXCEPT;

    template <class _Tp>
    _LIBCPP_METHOD_TEMPLATE_IMPLICIT_INSTANTIATION_VIS _LIBCPP_CONSTEXPR_AFTER_CXX17
    __enable_if_t
        <
            __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,
            size_type
        >
              find_first_not_of(const _Tp &__t, size_type __pos = 0) const _NOEXCEPT;
    _LIBCPP_CONSTEXPR_AFTER_CXX17
    size_type find_first_not_of(const value_type* __s, size_type __pos, size_type __n) const _NOEXCEPT;
    _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_AFTER_CXX17
    size_type find_first_not_of(const value_type* __s, size_type __pos = 0) const _NOEXCEPT;
    _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_AFTER_CXX17
    size_type find_first_not_of(value_type __c, size_type __pos = 0) const _NOEXCEPT;

    _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_AFTER_CXX17
    size_type find_last_not_of(const basic_string& __str, size_type __pos = npos) const _NOEXCEPT;

    template <class _Tp>
    _LIBCPP_METHOD_TEMPLATE_IMPLICIT_INSTANTIATION_VIS _LIBCPP_CONSTEXPR_AFTER_CXX17
    __enable_if_t
        <
            __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,
            size_type
        >
              find_last_not_of(const _Tp& __t, size_type __pos = npos) const _NOEXCEPT;
    _LIBCPP_CONSTEXPR_AFTER_CXX17
    size_type find_last_not_of(const value_type* __s, size_type __pos, size_type __n) const _NOEXCEPT;
    _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_AFTER_CXX17
    size_type find_last_not_of(const value_type* __s, size_type __pos = npos) const _NOEXCEPT;
    _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_AFTER_CXX17
    size_type find_last_not_of(value_type __c, size_type __pos = npos) const _NOEXCEPT;

    _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_AFTER_CXX17
    int compare(const basic_string& __str) const _NOEXCEPT;

    template <class _Tp>
    _LIBCPP_METHOD_TEMPLATE_IMPLICIT_INSTANTIATION_VIS _LIBCPP_CONSTEXPR_AFTER_CXX17
    __enable_if_t
        <
            __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,
            int
        >
        compare(const _Tp &__t) const _NOEXCEPT;

    template <class _Tp>
    _LIBCPP_METHOD_TEMPLATE_IMPLICIT_INSTANTIATION_VIS _LIBCPP_CONSTEXPR_AFTER_CXX17
    __enable_if_t
        <
            __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,
            int
        >
         compare(size_type __pos1, size_type __n1, const _Tp& __t) const;

    _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_AFTER_CXX17
    int compare(size_type __pos1, size_type __n1, const basic_string& __str) const;
    _LIBCPP_CONSTEXPR_AFTER_CXX17
    int compare(size_type __pos1, size_type __n1, const basic_string& __str, size_type __pos2,
                size_type __n2 = npos) const;

    template <class _Tp>
    inline _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_AFTER_CXX17
        __enable_if_t
        <
            __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value  && !__is_same_uncvref<_Tp, basic_string>::value,
            int
        >
        compare(size_type __pos1, size_type __n1, const _Tp& __t, size_type __pos2, size_type __n2=npos) const;
    _LIBCPP_CONSTEXPR_AFTER_CXX17 int compare(const value_type* __s) const _NOEXCEPT;
    _LIBCPP_CONSTEXPR_AFTER_CXX17 int compare(size_type __pos1, size_type __n1, const value_type* __s) const;
    _LIBCPP_CONSTEXPR_AFTER_CXX17
    int compare(size_type __pos1, size_type __n1, const value_type* __s, size_type __n2) const;

#if _LIBCPP_STD_VER > 17
    constexpr _LIBCPP_HIDE_FROM_ABI
    bool starts_with(__self_view __sv) const noexcept
    { return __self_view(data(), size()).starts_with(__sv); }

    constexpr _LIBCPP_HIDE_FROM_ABI
    bool starts_with(value_type __c) const noexcept
    { return !empty() && _Traits::eq(front(), __c); }

    constexpr _LIBCPP_HIDE_FROM_ABI
    bool starts_with(const value_type* __s) const noexcept
    { return starts_with(__self_view(__s)); }

    constexpr _LIBCPP_HIDE_FROM_ABI
    bool ends_with(__self_view __sv) const noexcept
    { return __self_view(data(), size()).ends_with( __sv); }

    constexpr _LIBCPP_HIDE_FROM_ABI
    bool ends_with(value_type __c) const noexcept
    { return !empty() && _Traits::eq(back(), __c); }

    constexpr _LIBCPP_HIDE_FROM_ABI
    bool ends_with(const value_type* __s) const noexcept
    { return ends_with(__self_view(__s)); }
#endif

#if _LIBCPP_STD_VER > 20
    constexpr _LIBCPP_HIDE_FROM_ABI
    bool contains(__self_view __sv) const noexcept
    { return __self_view(data(), size()).contains(__sv); }

    constexpr _LIBCPP_HIDE_FROM_ABI
    bool contains(value_type __c) const noexcept
    { return __self_view(data(), size()).contains(__c); }

    constexpr _LIBCPP_HIDE_FROM_ABI
    bool contains(const value_type* __s) const
    { return __self_view(data(), size()).contains(__s); }
#endif

    _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_AFTER_CXX17 bool __invariants() const;

    _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_AFTER_CXX17 void __clear_and_shrink() _NOEXCEPT;

#ifdef _LIBCPP_ENABLE_DEBUG_MODE

    bool __dereferenceable(const const_iterator* __i) const;
    bool __decrementable(const const_iterator* __i) const;
    bool __addable(const const_iterator* __i, ptrdiff_t __n) const;
    bool __subscriptable(const const_iterator* __i, ptrdiff_t __n) const;

#endif // _LIBCPP_ENABLE_DEBUG_MODE

private:
    template<class _Alloc>
    inline _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_AFTER_CXX17
    bool friend operator==(const basic_string<char, char_traits<char>, _Alloc>& __lhs,
                           const basic_string<char, char_traits<char>, _Alloc>& __rhs) _NOEXCEPT;

    _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_AFTER_CXX17 void __shrink_or_extend(size_type __target_capacity);

    _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_AFTER_CXX17
    bool __is_long() const _NOEXCEPT {
        if (__libcpp_is_constant_evaluated())
            return true;
        return __r_.first().__s.__is_long_;
    }

    static _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_AFTER_CXX17 void __begin_lifetime(pointer __begin, size_type __n) {
#if _LIBCPP_STD_VER > 17
        if (__libcpp_is_constant_evaluated()) {
            for (size_type __i = 0; __i != __n; ++__i)
                std::construct_at(std::addressof(__begin[__i]));
        }
#else
        (void)__begin;
        (void)__n;
#endif // _LIBCPP_STD_VER > 17
    }

    _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_AFTER_CXX17 void __default_init() {
        __zero();
        if (__libcpp_is_constant_evaluated()) {
            size_type __sz = __recommend(0) + 1;
            pointer __ptr = __alloc_traits::allocate(__alloc(), __sz);
            __begin_lifetime(__ptr, __sz);
            __set_long_pointer(__ptr);
            __set_long_cap(__sz);
            __set_long_size(0);
        }
    }

    _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_AFTER_CXX17 void __deallocate_constexpr() {
        if (__libcpp_is_constant_evaluated() && __get_pointer() != nullptr)
            __alloc_traits::deallocate(__alloc(), __get_pointer(), __get_long_cap());
    }

    _LIBCPP_CONSTEXPR _LIBCPP_HIDE_FROM_ABI static bool __fits_in_sso(size_type __sz) {
        // SSO is disabled during constant evaluation because `__is_long` isn't constexpr friendly
        return !__libcpp_is_constant_evaluated() && (__sz < __min_cap);
    }

    template <class _ForwardIterator>
    _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_AFTER_CXX11
    iterator __insert_from_safe_copy(size_type __n, size_type __ip, _ForwardIterator __first, _ForwardIterator __last) {
        size_type __sz = size();
        size_type __cap = capacity();
        value_type* __p;
        if (__cap - __sz >= __n)
        {
            __p = std::__to_address(__get_pointer());
            size_type __n_move = __sz - __ip;
            if (__n_move != 0)
                traits_type::move(__p + __ip + __n, __p + __ip, __n_move);
        }
        else
        {
            __grow_by(__cap, __sz + __n - __cap, __sz, __ip, 0, __n);
            __p = std::__to_address(__get_long_pointer());
        }
        __sz += __n;
        __set_size(__sz);
        traits_type::assign(__p[__sz], value_type());
        for (__p += __ip; __first != __last; ++__p, ++__first)
            traits_type::assign(*__p, *__first);

        return begin() + __ip;
    }

    _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_AFTER_CXX11 allocator_type& __alloc() _NOEXCEPT { return __r_.second(); }
    _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR const allocator_type& __alloc() const _NOEXCEPT { return __r_.second(); }

    _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_AFTER_CXX17
    void __set_short_size(size_type __s) _NOEXCEPT {
        _LIBCPP_ASSERT(__s < __min_cap, "__s should never be greater than or equal to the short string capacity");
        __r_.first().__s.__size_ = __s;
        __r_.first().__s.__is_long_ = false;
    }

    _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_AFTER_CXX17
    size_type __get_short_size() const _NOEXCEPT {
        _LIBCPP_ASSERT(!__r_.first().__s.__is_long_, "String has to be short when trying to get the short size");
        return __r_.first().__s.__size_;
    }

    _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_AFTER_CXX17
    void __set_long_size(size_type __s) _NOEXCEPT
        {__r_.first().__l.__size_ = __s;}
    _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_AFTER_CXX17
    size_type __get_long_size() const _NOEXCEPT
        {return __r_.first().__l.__size_;}
    _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_AFTER_CXX17
    void __set_size(size_type __s) _NOEXCEPT
        {if (__is_long()) __set_long_size(__s); else __set_short_size(__s);}

    _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_AFTER_CXX17
    void __set_long_cap(size_type __s) _NOEXCEPT {
        __r_.first().__l.__cap_ = __s / __endian_factor;
        __r_.first().__l.__is_long_ = true;
    }

    _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_AFTER_CXX17
    size_type __get_long_cap() const _NOEXCEPT {
        return __r_.first().__l.__cap_ * __endian_factor;
    }

    _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_AFTER_CXX17
    void __set_long_pointer(pointer __p) _NOEXCEPT
        {__r_.first().__l.__data_ = __p;}
    _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_AFTER_CXX17
    pointer __get_long_pointer() _NOEXCEPT
        {return __r_.first().__l.__data_;}
    _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_AFTER_CXX17
    const_pointer __get_long_pointer() const _NOEXCEPT
        {return __r_.first().__l.__data_;}
    _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_AFTER_CXX17
    pointer __get_short_pointer() _NOEXCEPT
        {return pointer_traits<pointer>::pointer_to(__r_.first().__s.__data_[0]);}
    _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_AFTER_CXX17
    const_pointer __get_short_pointer() const _NOEXCEPT
        {return pointer_traits<const_pointer>::pointer_to(__r_.first().__s.__data_[0]);}
    _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_AFTER_CXX17
    pointer __get_pointer() _NOEXCEPT
        {return __is_long() ? __get_long_pointer() : __get_short_pointer();}
    _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_AFTER_CXX17
    const_pointer __get_pointer() const _NOEXCEPT
        {return __is_long() ? __get_long_pointer() : __get_short_pointer();}

    _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_AFTER_CXX17
    void __zero() _NOEXCEPT {
        __r_.first() = __rep();
    }

    template <size_type __a> static
        _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_AFTER_CXX17
        size_type __align_it(size_type __s) _NOEXCEPT
            {return (__s + (__a-1)) & ~(__a-1);}
    enum {__alignment = 16};
    static _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_AFTER_CXX17
    size_type __recommend(size_type __s) _NOEXCEPT
    {
        if (__s < __min_cap) {
            if (__libcpp_is_constant_evaluated())
                return static_cast<size_type>(__min_cap);
            else
                return static_cast<size_type>(__min_cap) - 1;
        }
        size_type __guess = __align_it<sizeof(value_type) < __alignment ?
                     __alignment/sizeof(value_type) : 1 > (__s+1) - 1;
        if (__guess == __min_cap) ++__guess;
        return __guess;
    }

    inline _LIBCPP_CONSTEXPR_AFTER_CXX17
    void __init(const value_type* __s, size_type __sz, size_type __reserve);
    inline _LIBCPP_CONSTEXPR_AFTER_CXX17
    void __init(const value_type* __s, size_type __sz);
    inline _LIBCPP_CONSTEXPR_AFTER_CXX17
    void __init(size_type __n, value_type __c);

    // Slow path for the (inlined) copy constructor for 'long' strings.
    // Always externally instantiated and not inlined.
    // Requires that __s is zero terminated.
    // The main reason for this function to exist is because for unstable, we
    // want to allow inlining of the copy constructor. However, we don't want
    // to call the __init() functions as those are marked as inline which may
    // result in over-aggressive inlining by the compiler, where our aim is
    // to only inline the fast path code directly in the ctor.
    _LIBCPP_CONSTEXPR_AFTER_CXX17 void __init_copy_ctor_external(const value_type* __s, size_type __sz);

    template <class _InputIterator>
    inline _LIBCPP_CONSTEXPR_AFTER_CXX17
    __enable_if_t
    <
        __is_exactly_cpp17_input_iterator<_InputIterator>::value
    >
    __init(_InputIterator __first, _InputIterator __last);

    template <class _ForwardIterator>
    inline _LIBCPP_CONSTEXPR_AFTER_CXX17
    __enable_if_t
    <
        __is_cpp17_forward_iterator<_ForwardIterator>::value
    >
    __init(_ForwardIterator __first, _ForwardIterator __last);

    _LIBCPP_CONSTEXPR_AFTER_CXX17
    void __grow_by(size_type __old_cap, size_type __delta_cap, size_type __old_sz,
                   size_type __n_copy,  size_type __n_del,     size_type __n_add = 0);
    _LIBCPP_CONSTEXPR_AFTER_CXX17
    void __grow_by_and_replace(size_type __old_cap, size_type __delta_cap, size_type __old_sz,
                               size_type __n_copy,  size_type __n_del,
                               size_type __n_add, const value_type* __p_new_stuff);

    // __assign_no_alias is invoked for assignment operations where we
    // have proof that the input does not alias the current instance.
    // For example, operator=(basic_string) performs a 'self' check.
    template <bool __is_short>
    _LIBCPP_CONSTEXPR_AFTER_CXX17 basic_string& __assign_no_alias(const value_type* __s, size_type __n);

    _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_AFTER_CXX17
    void __erase_to_end(size_type __pos);

    // __erase_external_with_move is invoked for erase() invocations where
    // `n ~= npos`, likely requiring memory moves on the string data.
    _LIBCPP_CONSTEXPR_AFTER_CXX17 void __erase_external_with_move(size_type __pos, size_type __n);

    _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_AFTER_CXX17
    void __copy_assign_alloc(const basic_string& __str)
        {__copy_assign_alloc(__str, integral_constant<bool,
                      __alloc_traits::propagate_on_container_copy_assignment::value>());}

    _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_AFTER_CXX17
    void __copy_assign_alloc(const basic_string& __str, true_type)
        {
            if (__alloc() == __str.__alloc())
                __alloc() = __str.__alloc();
            else
            {
                if (!__str.__is_long())
                {
                    __clear_and_shrink();
                    __alloc() = __str.__alloc();
                }
                else
                {
                    allocator_type __a = __str.__alloc();
                    auto __allocation = std::__allocate_at_least(__a, __str.__get_long_cap());
                    __begin_lifetime(__allocation.ptr, __allocation.count);
                    __clear_and_shrink();
                    __alloc() = std::move(__a);
                    __set_long_pointer(__allocation.ptr);
                    __set_long_cap(__allocation.count);
                    __set_long_size(__str.size());
                }
            }
        }

    _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_AFTER_CXX17
    void __copy_assign_alloc(const basic_string&, false_type) _NOEXCEPT
        {}

#ifndef _LIBCPP_CXX03_LANG
    _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_AFTER_CXX17
    void __move_assign(basic_string& __str, false_type)
        _NOEXCEPT_(__alloc_traits::is_always_equal::value);
    _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_AFTER_CXX17
    void __move_assign(basic_string& __str, true_type)
#if _LIBCPP_STD_VER > 14
        _NOEXCEPT;
#else
        _NOEXCEPT_(is_nothrow_move_assignable<allocator_type>::value);
#endif
#endif

    _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_AFTER_CXX17
    void
    __move_assign_alloc(basic_string& __str)
        _NOEXCEPT_(
            !__alloc_traits::propagate_on_container_move_assignment::value ||
            is_nothrow_move_assignable<allocator_type>::value)
    {__move_assign_alloc(__str, integral_constant<bool,
                      __alloc_traits::propagate_on_container_move_assignment::value>());}

    _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_AFTER_CXX17
    void __move_assign_alloc(basic_string& __c, true_type)
        _NOEXCEPT_(is_nothrow_move_assignable<allocator_type>::value)
        {
            __alloc() = std::move(__c.__alloc());
        }

    _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_AFTER_CXX17
    void __move_assign_alloc(basic_string&, false_type)
        _NOEXCEPT
        {}

    _LIBCPP_CONSTEXPR_AFTER_CXX17 basic_string& __assign_external(const value_type* __s);
    _LIBCPP_CONSTEXPR_AFTER_CXX17 basic_string& __assign_external(const value_type* __s, size_type __n);

    // Assigns the value in __s, guaranteed to be __n < __min_cap in length.
    inline basic_string& __assign_short(const value_type* __s, size_type __n) {
      pointer __p = __is_long()
                        ? (__set_long_size(__n), __get_long_pointer())
                        : (__set_short_size(__n), __get_short_pointer());
      traits_type::move(std::__to_address(__p), __s, __n);
      traits_type::assign(__p[__n], value_type());
      return *this;
    }

    _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_AFTER_CXX17
    basic_string& __null_terminate_at(value_type* __p, size_type __newsz) {
      __set_size(__newsz);
      __invalidate_iterators_past(__newsz);
      traits_type::assign(__p[__newsz], value_type());
      return *this;
    }

    _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_AFTER_CXX17 void __invalidate_iterators_past(size_type);

    template<class _Tp>
    _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_AFTER_CXX17
    bool __addr_in_range(_Tp&& __t) const {
        // assume that the ranges overlap, because we can't check during constant evaluation
        if (__libcpp_is_constant_evaluated())
          return true;
        const volatile void *__p = std::addressof(__t);
        return data() <= __p && __p <= data() + size();
    }

    _LIBCPP_NORETURN _LIBCPP_HIDE_FROM_ABI
    void __throw_length_error() const {
        std::__throw_length_error("basic_string");
    }

    _LIBCPP_NORETURN _LIBCPP_HIDE_FROM_ABI
    void __throw_out_of_range() const {
        std::__throw_out_of_range("basic_string");
    }

    friend _LIBCPP_CONSTEXPR_AFTER_CXX17 basic_string operator+<>(const basic_string&, const basic_string&);
    friend _LIBCPP_CONSTEXPR_AFTER_CXX17 basic_string operator+<>(const value_type*, const basic_string&);
    friend _LIBCPP_CONSTEXPR_AFTER_CXX17 basic_string operator+<>(value_type, const basic_string&);
    friend _LIBCPP_CONSTEXPR_AFTER_CXX17 basic_string operator+<>(const basic_string&, const value_type*);
    friend _LIBCPP_CONSTEXPR_AFTER_CXX17 basic_string operator+<>(const basic_string&, value_type);
};

// These declarations must appear before any functions are implicitly used
// so that they have the correct visibility specifier.
#define _LIBCPP_DECLARE(...) extern template __VA_ARGS__;
#ifdef _LIBCPP_ABI_STRING_OPTIMIZED_EXTERNAL_INSTANTIATION
    _LIBCPP_STRING_UNSTABLE_EXTERN_TEMPLATE_LIST(_LIBCPP_DECLARE, char)
#   ifndef _LIBCPP_HAS_NO_WIDE_CHARACTERS
        _LIBCPP_STRING_UNSTABLE_EXTERN_TEMPLATE_LIST(_LIBCPP_DECLARE, wchar_t)
#   endif
#else
    _LIBCPP_STRING_V1_EXTERN_TEMPLATE_LIST(_LIBCPP_DECLARE, char)
#   ifndef _LIBCPP_HAS_NO_WIDE_CHARACTERS
        _LIBCPP_STRING_V1_EXTERN_TEMPLATE_LIST(_LIBCPP_DECLARE, wchar_t)
#   endif
#endif
#undef _LIBCPP_DECLARE


#if _LIBCPP_STD_VER >= 17
template<class _InputIterator,
         class _CharT = __iter_value_type<_InputIterator>,
         class _Allocator = allocator<_CharT>,
         class = enable_if_t<__is_cpp17_input_iterator<_InputIterator>::value>,
         class = enable_if_t<__is_allocator<_Allocator>::value>
         >
basic_string(_InputIterator, _InputIterator, _Allocator = _Allocator())
  -> basic_string<_CharT, char_traits<_CharT>, _Allocator>;

template<class _CharT,
         class _Traits,
         class _Allocator = allocator<_CharT>,
         class = enable_if_t<__is_allocator<_Allocator>::value>
         >
explicit basic_string(basic_string_view<_CharT, _Traits>, const _Allocator& = _Allocator())
  -> basic_string<_CharT, _Traits, _Allocator>;

template<class _CharT,
         class _Traits,
         class _Allocator = allocator<_CharT>,
         class = enable_if_t<__is_allocator<_Allocator>::value>,
         class _Sz = typename allocator_traits<_Allocator>::size_type
         >
basic_string(basic_string_view<_CharT, _Traits>, _Sz, _Sz, const _Allocator& = _Allocator())
  -> basic_string<_CharT, _Traits, _Allocator>;
#endif

template <class _CharT, class _Traits, class _Allocator>
inline _LIBCPP_CONSTEXPR_AFTER_CXX17
void
basic_string<_CharT, _Traits, _Allocator>::__invalidate_iterators_past(size_type __pos)
{
#ifdef _LIBCPP_ENABLE_DEBUG_MODE
    if (!__libcpp_is_constant_evaluated()) {
        __c_node* __c = __get_db()->__find_c_and_lock(this);
        if (__c)
        {
            const_pointer __new_last = __get_pointer() + __pos;
            for (__i_node** __p = __c->end_; __p != __c->beg_; )
            {
                --__p;
                const_iterator* __i = static_cast<const_iterator*>((*__p)->__i_);
                if (__i->base() > __new_last)
                {
                    (*__p)->__c_ = nullptr;
                    if (--__c->end_ != __p)
                        std::memmove(__p, __p+1, (__c->end_ - __p)*sizeof(__i_node*));
                }
            }
            __get_db()->unlock();
        }
    }
#else
    (void)__pos;
#endif // _LIBCPP_ENABLE_DEBUG_MODE
}

template <class _CharT, class _Traits, class _Allocator>
inline _LIBCPP_CONSTEXPR_AFTER_CXX17
basic_string<_CharT, _Traits, _Allocator>::basic_string()
    _NOEXCEPT_(is_nothrow_default_constructible<allocator_type>::value)
     : __r_(__default_init_tag(), __default_init_tag())
{
    std::__debug_db_insert_c(this);
    __default_init();
}

template <class _CharT, class _Traits, class _Allocator>
inline _LIBCPP_CONSTEXPR_AFTER_CXX17
basic_string<_CharT, _Traits, _Allocator>::basic_string(const allocator_type& __a)
#if _LIBCPP_STD_VER <= 14
        _NOEXCEPT_(is_nothrow_copy_constructible<allocator_type>::value)
#else
        _NOEXCEPT
#endif
: __r_(__default_init_tag(), __a)
{
    std::__debug_db_insert_c(this);
    __default_init();
}

template <class _CharT, class _Traits, class _Allocator>
_LIBCPP_CONSTEXPR_AFTER_CXX17
void basic_string<_CharT, _Traits, _Allocator>::__init(const value_type* __s,
                                                       size_type __sz,
                                                       size_type __reserve)
{
    if (__libcpp_is_constant_evaluated())
        __zero();
    if (__reserve > max_size())
        __throw_length_error();
    pointer __p;
    if (__fits_in_sso(__reserve))
    {
        __set_short_size(__sz);
        __p = __get_short_pointer();
    }
    else
    {
        auto __allocation = std::__allocate_at_least(__alloc(), __recommend(__reserve) + 1);
        __p = __allocation.ptr;
        __begin_lifetime(__p, __allocation.count);
        __set_long_pointer(__p);
        __set_long_cap(__allocation.count);
        __set_long_size(__sz);
    }
    traits_type::copy(std::__to_address(__p), __s, __sz);
    traits_type::assign(__p[__sz], value_type());
}

template <class _CharT, class _Traits, class _Allocator>
_LIBCPP_CONSTEXPR_AFTER_CXX17
void
basic_string<_CharT, _Traits, _Allocator>::__init(const value_type* __s, size_type __sz)
{
    if (__libcpp_is_constant_evaluated())
        __zero();
    if (__sz > max_size())
        __throw_length_error();
    pointer __p;
    if (__fits_in_sso(__sz))
    {
        __set_short_size(__sz);
        __p = __get_short_pointer();
    }
    else
    {
        auto __allocation = std::__allocate_at_least(__alloc(), __recommend(__sz) + 1);
        __p = __allocation.ptr;
        __begin_lifetime(__p, __allocation.count);
        