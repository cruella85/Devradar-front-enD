// -*- C++ -*-
//===----------------------------------------------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//

#ifndef _LIBCPP_STRING
#define _LIBCPP_STRING

/*
    string synopsis

namespace std
{

template <class stateT>
class fpos
{
private:
    stateT st;
public:
    fpos(streamoff = streamoff());

    operator streamoff() const;

    stateT state() const;
    void state(stateT);

    fpos& operator+=(streamoff);
    fpos  operator+ (streamoff) const;
    fpos& operator-=(streamoff);
    fpos  operator- (streamoff) const;
};

template <class stateT> streamoff operator-(const fpos<stateT>& x, const fpos<stateT>& y);

template <class stateT> bool operator==(const fpos<stateT>& x, const fpos<stateT>& y);
template <class stateT> bool operator!=(const fpos<stateT>& x, const fpos<stateT>& y);

template <class charT>
struct char_traits
{
    typedef charT     char_type;
    typedef ...       int_type;
    typedef streamoff off_type;
    typedef streampos pos_type;
    typedef mbstate_t state_type;

    static void assign(char_type& c1, const char_type& c2) noexcept;
    static constexpr bool eq(char_type c1, char_type c2) noexcept;
    static constexpr bool lt(char_type c1, char_type c2) noexcept;

    static int              compare(const char_type* s1, const char_type* s2, size_t n);
    static size_t           length(const char_type* s);
    static const char_type* find(const char_type* s, size_t n, const char_type& a);
    static char_type*       move(char_type* s1, const char_type* s2, size_t n);
    static char_type*       copy(char_type* s1, const char_type* s2, size_t n);
    static char_type*       assign(char_type* s, size_t n, char_type a);

    static constexpr int_type  not_eof(int_type c) noexcept;
    static constexpr char_type to_char_type(int_type c) noexcept;
    static constexpr int_type  to_int_type(char_type c) noexcept;
    static constexpr bool      eq_int_type(int_type c1, int_type c2) noexcept;
    static constexpr int_type  eof() noexcept;
};

template <> struct char_traits<char>;
template <> struct char_traits<wchar_t>;
template <> struct char_traits<char8_t>;  // C++20
template <> struct char_traits<char16_t>;
template <> struct char_traits<char32_t>;

template<class charT, class traits = char_traits<charT>, class Allocator = allocator<charT> >
class basic_string
{
public:
// types:
    typedef traits traits_type;
    typedef typename traits_type::char_type value_type;
    typedef Allocator allocator_type;
    typedef typename allocator_type::size_type size_type;
    typedef typename allocator_type::difference_type difference_type;
    typedef typename allocator_type::reference reference;
    typedef typename allocator_type::const_reference const_reference;
    typedef typename allocator_type::pointer pointer;
    typedef typename allocator_type::const_pointer const_pointer;
    typedef implementation-defined iterator;
    typedef implementation-defined const_iterator;
    typedef std::reverse_iterator<iterator> reverse_iterator;
    typedef std::reverse_iterator<const_iterator> const_reverse_iterator;

    static const size_type npos = -1;

    basic_string()
        noexcept(is_nothrow_default_constructible<allocator_type>::value);                      // constexpr since C++20
    explicit basic_string(const allocator_type& a);                                             // constexpr since C++20
    basic_string(const basic_string& str);                                                      // constexpr since C++20
    basic_string(basic_string&& str)
        noexcept(is_nothrow_move_constructible<allocator_type>::value);                         // constexpr since C++20
    basic_string(const basic_string& str, size_type pos,
                 const allocator_type& a = allocator_type());                                   // constexpr since C++20
    basic_string(const basic_string& str, size_type pos, size_type n,
                 const Allocator& a = Allocator());                                             // constexpr since C++20
    template<class T>
        basic_string(const T& t, size_type pos, size_type n, const Allocator& a = Allocator()); // C++17, constexpr since C++20
    template <class T>
        explicit basic_string(const T& t, const Allocator& a = Allocator());                    // C++17, constexpr since C++20
    basic_string(const value_type* s, const allocator_type& a = allocator_type());              // constexpr since C++20
    basic_string(const value_type* s, size_type n, const allocator_type& a = allocator_type()); // constexpr since C++20
    basic_string(nullptr_t) = delete; // C++2b
    basic_string(size_type n, value_type c, const allocator_type& a = allocator_type());        // constexpr since C++20
    template<class InputIterator>
        basic_string(InputIterator begin, InputIterator end,
                     const allocator_type& a = allocator_type());                               // constexpr since C++20
    basic_string(initializer_list<value_type>, const Allocator& = Allocator());                 // constexpr since C++20
    basic_string(const basic_string&, const Allocator&);                                        // constexpr since C++20
    basic_string(basic_string&&, const Allocator&);                                             // constexpr since C++20

    ~basic_string();                                                                            // constexpr since C++20

    operator basic_string_view<charT, traits>() const noexcept;                                 // constexpr since C++20

    basic_string& operator=(const basic_string& str);                                           // constexpr since C++20
    template <class T>
        basic_string& operator=(const T& t);                                                    // C++17, constexpr since C++20
    basic_string& operator=(basic_string&& str)
        noexcept(
             allocator_type::propagate_on_container_move_assignment::value ||
             allocator_type::is_always_equal::value );                                          // C++17, constexpr since C++20
    basic_string& operator=(const value_type* s);                                               // constexpr since C++20
    basic_string& operator=(nullptr_t) = delete; // C++2b
    basic_string& operator=(value_type c);                                                      // constexpr since C++20
    basic_string& operator=(initializer_list<value_type>);                                      // constexpr since C++20

    iterator       begin() noexcept;                                                            // constexpr since C++20
    const_iterator begin() const noexcept;                                                      // constexpr since C++20
    iterator       end() noexcept;                                                              // constexpr since C++20
    const_iterator end() const noexcept;                                                        // constexpr since C++20

    reverse_iterator       rbegin() noexcept;                                                   // constexpr since C++20
    const_reverse_iterator rbegin() const noexcept;                                             // constexpr since C++20
    reverse_iterator       rend() noexcept;                                                     // constexpr since C++20
    const_reverse_iterator rend() const noexcept;                                               // constexpr since C++20

    const_iterator         cbegin() const noexcept;                                             // constexpr since C++20
    const_iterator         cend() const noexcept;                                               // constexpr since C++20
    const_reverse_iterator crbegin() const noexcept;                                            // constexpr since C++20
    const_reverse_iterator crend() const noexcept;                                              // constexpr since C++20

    size_type size() const noexcept;                                                            // constexpr since C++20
    size_type length() const noexcept;                                                          // constexpr since C++20
    size_type max_size() const noexcept;                                                        // constexpr since C++20
    size_type capacity() const noexcept;                                                        // constexpr since C++20

    void resize(size_type n, value_type c);                                                     // constexpr since C++20
    void resize(size_type n);                                                                   // constexpr since C++20

    template<class Operation>
    constexpr void resize_and_overwrite(size_type n, Operation op); // since C++23

    void reserve(size_type res_arg);                                                            // constexpr since C++20
    void reserve(); // deprecated in C++20
    void shrink_to_fit();                                                                       // constexpr since C++20
    void clear() noexcept;                                                                      // constexpr since C++20
    bool empty() const noexcept;                                                                // constexpr since C++20

    const_reference operator[](size_type pos) const;                                            // constexpr since C++20
    reference       operator[](size_type pos);                                                  // constexpr since C++20

    const_reference at(size_type n) const;                                                      // constexpr since C++20
    reference       at(size_type n);                                                            // constexpr since C++20

    basic_string& operator+=(const basic_string& str);                                          // constexpr since C++20
    template <class T>
        basic_string& operator+=(const T& t);                                                   // C++17, constexpr since C++20
    basic_string& operator+=(const value_type* s);                                              // constexpr since C++20
    basic_string& operator+=(value_type c);                                                     // constexpr since C++20
    basic_string& operator+=(initializer_list<value_type>);                                     // constexpr since C++20

    basic_string& append(const basic_string& str);                                              // constexpr since C++20
    template <class T>
        basic_string& append(const T& t);                                                       // C++17, constexpr since C++20
    basic_string& append(const basic_string& str, size_type pos, size_type n=npos);             // C++14, constexpr since C++20
    template <class T>
        basic_string& append(const T& t, size_type pos, size_type n=npos);                      // C++17, constexpr since C++20
    basic_string& append(const value_type* s, size_type n);                                     // constexpr since C++20
    basic_string& append(const value_type* s);                                                  // constexpr since C++20
    basic_string& append(size_type n, value_type c);                                            // constexpr since C++20
    template<class InputIterator>
        basic_string& append(InputIterator first, InputIterator last);                          // constexpr since C++20
    basic_string& append(initializer_list<value_type>);                                         // constexpr since C++20

    void push_back(value_type c);                                                               // constexpr since C++20
    void pop_back();                                                                            // constexpr since C++20
    reference       front();                                                                    // constexpr since C++20
    const_reference front() const;                                                              // constexpr since C++20
    reference       back();                                                                     // constexpr since C++20
    const_reference back() const;                                                               // constexpr since C++20

    basic_string& assign(const basic_string& str);                                              // constexpr since C++20
    template <class T>
        basic_string& assign(const T& t);                                                       // C++17, constexpr since C++20
    basic_string& assign(basic_string&& str);                                                   // constexpr since C++20
    basic_string& assign(const basic_string& str, size_type pos, size_type n=npos);             // C++14, constexpr since C++20
    template <class T>
        basic_string& assign(const T& t, size_type pos, size_type n=npos);                      // C++17, constexpr since C++20
    basic_string& assign(const value_type* s, size_type n);                                     // constexpr since C++20
    basic_string& assign(const value_type* s);                                                  // constexpr since C++20
    basic_string& assign(size_type n, value_type c);                                            // constexpr since C++20
    template<class InputIterator>
        basic_string& assign(InputIterator first, InputIterator last);                          // constexpr since C++20
    basic_string& assign(initializer_list<value_type>);                                         // constexpr since C++20

    basic_string& insert(size_type pos1, const basic_string& str);                              // constexpr since C++20
    template <class T>
        basic_string& insert(size_type pos1, const T& t);                                       // constexpr since C++20
    basic_string& insert(size_type pos1, const basic_string& str,
                         size_type pos2, size_type n);                                          // constexpr since C++20
    template <class T>
        basic_string& insert(size_type pos1, const T& t, size_type pos2, size_type n);          // C++17, constexpr since C++20
    basic_string& insert(size_type pos, const value_type* s, size_type n=npos);                 // C++14, constexpr since C++20
    basic_string& insert(size_type pos, const value_type* s);                                   // constexpr since C++20
    basic_string& insert(size_type pos, size_type n, value_type c);                             // constexpr since C++20
    iterator      insert(const_iterator p, value_type c);                                       // constexpr since C++20
    iterator      insert(const_iterator p, size_type n, value_type c);                          // constexpr since C++20
    template<class InputIterator>
        iterator insert(const_iterator p, InputIterator first, InputIterator last);             // constexpr since C++20
    iterator      insert(const_iterator p, initializer_list<value_type>);                       // constexpr since C++20

    basic_string& erase(size_type pos = 0, size_type n = npos);                                 // constexpr since C++20
    iterator      erase(const_iterator position);                                               // constexpr since C++20
    iterator      erase(const_iterator first, const_iterator last);                             // constexpr since C++20

    basic_string& replace(size_type pos1, size_type n1, const basic_string& str);               // constexpr since C++20
    template <class T>
    basic_string& replace(size_type pos1, size_type n1, const T& t);                            // C++17, constexpr since C++20
    basic_string& replace(size_type pos1, size_type n1, const basic_string& str,
                          size_type pos2, size_type n2=npos);                                   // C++14, constexpr since C++20
    template <class T>
        basic_string& replace(size_type pos1, size_type n1, const T& t,
                              size_type pos2, size_type n);                                     // C++17, constexpr since C++20
    basic_string& replace(size_type pos, size_type n1, const value_type* s, size_type n2);      // constexpr since C++20
    basic_string& replace(size_type pos, size_type n1, const value_type* s);                    // constexpr since C++20
    basic_string& replace(size_type pos, size_type n1, size_type n2, value_type c);             // constexpr since C++20
    basic_string& replace(const_iterator i1, const_iterator i2, const basic_string& str);       // constexpr since C++20
    template <class T>
        basic_string& replace(const_iterator i1, const_iterator i2, const T& t);                // C++17, constexpr since C++20
    basic_string& replace(const_iterator i1, const_iterator i2, const value_type* s, size_type n); // constexpr since C++20
    basic_string& replace(const_iterator i1, const_iterator i2, const value_type* s);           // constexpr since C++20
    basic_string& replace(const_iterator i1, const_iterator i2, size_type n, value_type c);     // constexpr since C++20
    template<class InputIterator>
        basic_string& replace(const_iterator i1, const_iterator i2, InputIterator j1, InputIterator j2); // constexpr since C++20
    basic_string& replace(const_iterator i1, const_iterator i2, initializer_list<value_type>);  // constexpr since C++20

    size_type copy(value_type* s, size_type n, size_type pos = 0) const;                        // constexpr since C++20
    basic_string substr(size_type pos = 0, size_type n = npos) const;                           // constexpr since C++20

    void swap(basic_string& str)
        noexcept(allocator_traits<allocator_type>::propagate_on_container_swap::value ||
                 allocator_traits<allocator_type>::is_always_equal::value);                     // C++17, constexpr since C++20

    const value_type* c_str() const noexcept;                                                   // constexpr since C++20
    const value_type* data() const noexcept;                                                    // constexpr since C++20
          value_type* data()       noexcept;                                                    // C++17, constexpr since C++20

    allocator_type get_allocator() const noexcept;                                              // constexpr since C++20

    size_type find(const basic_string& str, size_type pos = 0) const noexcept;                  // constexpr since C++20
    template <class T>
        size_type find(const T& t, size_type pos = 0) const noexcept;                           // C++17, noexcept as an extension, constexpr since C++20
    size_type find(const value_type* s, size_type pos, size_type n) const noexcept;             // constexpr since C++20
    size_type find(const value_type* s, size_type pos = 0) const noexcept;                      // constexpr since C++20
    size_type find(value_type c, size_type pos = 0) const noexcept;                             // constexpr since C++20

    size_type rfind(const basic_string& str, size_type pos = npos) const noexcept;              // constexpr since C++20
    template <class T>
        size_type rfind(const T& t, size_type pos = npos) const noexcept;                       // C++17, noexcept as an extension, constexpr since C++20
    size_type rfind(const value_type* s, size_type pos, size_type n) const noexcept;            // constexpr since C++20
    size_type rfind(const value_type* s, size_type pos = npos) const noexcept;                  // constexpr since C++20
    size_type rfind(value_type c, size_type pos = npos) const noexcept;                         // constexpr since C++20

    size_type find_first_of(const basic_string& str, size_type pos = 0) const noexcept;         // constexpr since C++20
    template <class T>
        size_type find_first_of(const T& t, size_type pos = 0) const noexcept;                  // C++17, noexcept as an extension, constexpr since C++20
    size_type find_first_of(const value_type* s, size_type pos, size_type n) const noexcept;    // constexpr since C++20
    size_type find_first_of(const value_type* s, size_type pos = 0) const noexcept;             // constexpr since C++20
    size_type find_first_of(value_type c, size_type pos = 0) const noexcept;                    // constexpr since C++20

    size_type find_last_of(const basic_string& str, size_type pos = npos) const noexcept;       // constexpr since C++20
    template <class T>
        size_type find_last_of(const T& t, size_type pos = npos) const noexcept noexcept;       // C++17, noexcept as an extension, constexpr since C++20
    size_type find_last_of(const value_type* s, size_type pos, size_type n) const noexcept;     // constexpr since C++20
    size_type find_last_of(const value_type* s, size_type pos = npos) const noexcept;           // constexpr since C++20
    size_type find_last_of(value_type c, size_type pos = npos) const noexcept;                  // constexpr since C++20

    size_type find_first_not_of(const basic_string& str, size_type pos = 0) const noexcept;     // constexpr since C++20
    template <class T>
        size_type find_first_not_of(const T& t, size_type pos = 0) const noexcept;              // C++17, noexcept as an extension, constexpr since C++20
    size_type find_first_not_of(const value_type* s, size_type pos, size_type n) const noexcept; // constexpr since C++20
    size_type find_first_not_of(const value_type* s, size_type pos = 0) const noexcept;         // constexpr since C++20
    size_type find_first_not_of(value_type c, size_type pos = 0) const noexcept;                // constexpr since C++20

    size_type find_last_not_of(const basic_string& str, size_type pos = npos) const noexcept;   // constexpr since C++20
    template <class T>
        size_type find_last_not_of(const T& t, size_type pos = npos) const noexcept;            // C++17, noexcept as an extension, constexpr since C++20
    size_type find_last_not_of(const value_type* s, size_type pos, size_type n) const noexcept; // constexpr since C++20
    size_type find_last_not_of(const value_type* s, size_type pos = npos) const noexcept;       // constexpr since C++20
    size_type find_last_not_of(value_type c, size_type pos = npos) const noexcept;              // constexpr since C++20

    int compare(const basic_string& str) const noexcept;                                        // constexpr since C++20
    template <class T>
        int compare(const T& t) const noexcept;                                                 // C++17, noexcept as an extension, constexpr since C++20
    int compare(size_type pos1, size_type n1, const basic_string& str) const;                   // constexpr since C++20
    template <class T>
        int compare(size_type pos1, size_type n1, const T& t) const;                            // C++17, constexpr since C++20
    int compare(size_type pos1, size_type n1, const basic_string& str,
                size_type pos2, size_type n2=npos) const;                                       // C++14, constexpr since C++20
    template <class T>
        int compare(size_type pos1, size_type n1, const T& t,
                    size_type pos2, size_type n2=npos) const;                                   // C++17, constexpr since C++20
    int compare(const value_type* s) const noexcept;                                            // constexpr since C++20
    int compare(size_type pos1, size_type n1, const value_type* s) const;                       // constexpr since C++20
    int compare(size_type pos1, size_type n1, const value_type* s, size_type n2) const;         // constexpr since C++20

    constexpr bool starts_with(basic_string_view<charT, traits> sv) const noexcept;             // C++20
    constexpr bool starts_with(charT c) const noexcept;                                         // C++20
    constexpr bool starts_with(const charT* s) const;                                           // C++20
    constexpr bool ends_with(basic_string_view<charT, traits> sv) const noexcept;               // C++20
    constexpr bool ends_with(charT c) const noexcept;                                           // C++20
    constexpr bool ends_with(const charT* s) const;                                             // C++20

    constexpr bool contains(basic_string_view<charT, traits> sv) const noexcept;                // C++2b
    constexpr bool contains(charT c) const noexcept;                                            // C++2b
    constexpr bool contains(const charT* s) const;                                              // C++2b
};

template<class InputIterator,
         class Allocator = allocator<typename iterator_traits<InputIterator>::value_type>>
basic_string(InputIterator, InputIterator, Allocator = Allocator())
   -> basic_string<typename iterator_traits<InputIterator>::value_type,
                  char_traits<typename iterator_traits<Input